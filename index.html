<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>zhangyong</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="zhangyong">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="zhangyong">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhangyong">
  
    <link rel="alternative" href="/atom.xml" title="zhangyong" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head></html>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars0.githubusercontent.com/u/39975746?s=400&amp;u=5c82d9ef34c547270f3fbe1d343a296e3ebdce25&amp;v=4" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">zhangyong</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">zhangyong</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars0.githubusercontent.com/u/39975746?s=400&amp;u=5c82d9ef34c547270f3fbe1d343a296e3ebdce25&amp;v=4" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">zhangyong</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-搭建docker镜像仓库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/02/搭建docker镜像仓库/" class="article-date">
  	<time datetime="2020-04-02T08:18:13.854Z" itemprop="datePublished">2020-04-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p><a href="https://docs.docker.com/registry/" target="_blank" rel="noopener">Docker Registry</a></p>
<pre><code>docker run -itd -v /root/data/registry:/var/lib/registry -p 5000:5000 --restart=always --name docker-registry registry:latest </code></pre><p>对于使用  systemd  的系统，请在  /etc/docker/daemon.json  中写入如下内容（如果文件不存<br>在请新建该文件）</p>
<pre><code>{
    &quot;registry-mirror&quot;: [
        &quot;https://registry.docker-cn.com&quot;
    ],
    &quot;insecure-registries&quot;: [
        &quot;192.168.199.100:5000&quot;
    ]
}</code></pre><p>当前镜像tag</p>
<pre><code>[root@JD ~]# docker tag mysql:5.7 127.0.0.1:5000/registry-mysql:5.7</code></pre><p>推送到镜像仓库</p>
<pre><code>[root@JD ~]# docker push 127.0.0.1:5000/registry-mysql</code></pre><p>用  curl  查看仓库中的镜像。</p>
<pre><code>[root@JD ~]# curl 127.0.0.1:5000/v2/_catalog
{&quot;repositories&quot;:[&quot;registry-mysql&quot;]}</code></pre><p> Docker 默认不允许非<code>HTTPS</code>方式推送镜像</p>
<p> <a href="https://blog.csdn.net/prince_mujia/article/details/105272760" target="_blank" rel="noopener">使用  Docker Compose  搭建一个拥有权限认证、TLS 的私有仓库</a></p>
<h2 id="harbor"><a href="#harbor" class="headerlink" title="harbor"></a>harbor</h2><h4 id="使用脚本搭建"><a href="#使用脚本搭建" class="headerlink" title="使用脚本搭建"></a>使用脚本搭建</h4><p>将harbor.sh脚本从 <a href="https://gist.github.com/kacole2/95e83ac84fec950b1a70b0853d6594dc" target="_blank" rel="noopener">GitHub Gist</a>下载到您的Ubuntu机器或VM。</p>
<p>harbor.sh脚本需要梯子才能下载。我在CSDN上传了一份<code>harbor：v1.10</code>版本的脚本。<br><a href="https://download.csdn.net/download/prince_mujia/12294781" target="_blank" rel="noopener">使用安装脚本快速部署Harbor的脚本文件-harbor.sh</a></p>
<p>向当前用户授予运行权限。</p>
<pre><code>chmod u+x</code></pre><p>要注意修改脚本中的端口号。</p>
<p>Harbor要求在目标主机上打开以下端口。</p>
<table>
<thead>
<tr>
<th align="left">港口</th>
<th align="left">协议</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">443</td>
<td align="left">HTTPS</td>
<td align="left">Harbor门户和核心API在此端口上接受HTTPS请求。您可以在配置文件中更改此端口。</td>
</tr>
<tr>
<td align="left">4443</td>
<td align="left">HTTPS</td>
<td align="left">与Harbor的Docker内容信任服务的连接。仅在启用公证人的情况下才需要。您可以在配置文件中更改此端口。</td>
</tr>
<tr>
<td align="left">80</td>
<td align="left">HTTP</td>
<td align="left">Harbor门户和核心API在此端口上接受HTTP请求。您可以在配置文件中更改此端口。</td>
</tr>
</tbody></table>
<p>以超级用户身份运行脚本。</p>
<pre><code>sudo ./harbor.sh</code></pre><p>选择是使用主机的IP地址还是FQDN部署Harbor。</p>
<pre><code>Would you like to install Harbor based on IP or FQDN?</code></pre><p>这是您访问Harbor接口和注册表服务的地址。</p>
<pre><code>要使用IP地址，请输入1。
要使用FQDN，请输入2。</code></pre><p>该脚本需要几分钟才能运行。在运行时，该脚本会从Ubuntu下载所需的软件包和依赖项，安装最新的稳定版本的Docker和Docker Compose，并安装最新的稳定版本的Harbor。</p>
<p>当脚本报告时Harbor Installation Complete，登录到新的Harbor实例。</p>
<pre><code>docker login &lt;harbor_ip_or_FQDN&gt;
用户名： admin
密码： VMware12345</code></pre><p>在浏览器中输入Harbor地址，以登录Harbor接口</p>
<h2 id="使用harbor-yml搭建"><a href="#使用harbor-yml搭建" class="headerlink" title="使用harbor.yml搭建"></a>使用harbor.yml搭建</h2><p><a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener">harbor 下载</a></p>
<h3 id="解压之后修改harbor-yml"><a href="#解压之后修改harbor-yml" class="headerlink" title="解压之后修改harbor.yml"></a>解压之后修改harbor.yml</h3><p><a href="https://goharbor.io/docs/1.10/install-config/configure-yml-file/" target="_blank" rel="noopener">配置YML文件</a></p>
<pre><code>hostname   这里设置本机的ip
harbor_admin_password    web页面的密码,默认的用户名和密码为admin和Harbor12345</code></pre><p>如果没有https，则需要先注释：</p>
<pre><code>https:
  # https port for harbor, default is 443
  port: 443
  # The path of cert and key files for nginx
  certificate: /your/certificate/path
  private_key: /your/private/key/path</code></pre><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><pre><code>sh ./install.sh

Creating harbor-log ... done
Creating registry      ... done
Creating harbor-db     ... done
Creating harbor-portal ... done
Creating redis         ... done
Creating registryctl   ... done
Creating harbor-core   ... done
Creating harbor-jobservice ... done
Creating nginx             ... done
✔ ----Harbor has been installed and started successfully.----</code></pre><h3 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h3><p><a href="https://114.67.79.102:8088" target="_blank" rel="noopener">https://114.67.79.102:8088</a></p>
<p><img src="//yoursite.com/2020/04/02/搭建docker镜像仓库/docker-harbor%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt></p>
<h3 id="建立https访问"><a href="#建立https访问" class="headerlink" title="建立https访问"></a>建立https访问</h3><h4 id="生成证书颁发机构证书"><a href="#生成证书颁发机构证书" class="headerlink" title="生成证书颁发机构证书"></a>生成证书颁发机构证书</h4><h5 id="生成CA证书私钥。"><a href="#生成CA证书私钥。" class="headerlink" title="生成CA证书私钥。"></a>生成CA证书私钥。</h5><pre><code>openssl genrsa -out ca.key 4096</code></pre><h5 id="生成CA证书。"><a href="#生成CA证书。" class="headerlink" title="生成CA证书。"></a>生成CA证书。</h5><p>调整-subj选项中的值以反映您的组织。如果使用FQDN连接Harbor主机，则必须将其指定为通用名称（CN）属性。</p>
<pre><code>openssl req -x509 -new -nodes -sha512 -days 3650 \
 -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=yourdomain.com&quot; \
 -key ca.key \
 -out ca.crt</code></pre><h4 id="生成服务器证书"><a href="#生成服务器证书" class="headerlink" title="生成服务器证书"></a>生成服务器证书</h4><p>证书通常包含一个.crt文件和一个.key文件，例如10.19.46.15.crt和10.19.46.15.key。</p>
<h5 id="生成私钥。"><a href="#生成私钥。" class="headerlink" title="生成私钥。"></a>生成私钥。</h5><pre><code>openssl genrsa -out 10.19.46.15.key 4096</code></pre><h5 id="生成证书签名请求（CSR）。"><a href="#生成证书签名请求（CSR）。" class="headerlink" title="生成证书签名请求（CSR）。"></a>生成证书签名请求（CSR）。</h5><p>调整-subj选项中的值以反映您的组织。如果使用FQDN连接Harbor主机，则必须将其指定为公用名（CN）属性，并在密钥和CSR文件名中使用它。</p>
<pre><code>openssl req -sha512 -new \
    -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=yourdomain.com&quot; \
    -key yourdomain.com.key \
    -out yourdomain.com.csr</code></pre><h5 id="生成一个x509-v3扩展文件。"><a href="#生成一个x509-v3扩展文件。" class="headerlink" title="生成一个x509 v3扩展文件。"></a>生成一个x509 v3扩展文件。</h5><p>无论您使用FQDN还是IP地址连接到Harbor主机，都必须创建此文件，以便可以为您的Harbor主机生成符合主题备用名称（SAN）和x509 v3的证书扩展要求。替换DNS条目以反映您的域。</p>
<pre><code>cat &gt; v3.ext &lt;&lt;-EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1=yourdomain.com
DNS.2=yourdomain
DNS.3=hostname
EOF</code></pre><h5 id="使用该v3-ext文件为您的Harbor主机生成证书。"><a href="#使用该v3-ext文件为您的Harbor主机生成证书。" class="headerlink" title="使用该v3.ext文件为您的Harbor主机生成证书。"></a>使用该v3.ext文件为您的Harbor主机生成证书。</h5><p>将yourdomain.comCRS和CRT文件名中的替换为Harbor主机名。</p>
<pre><code>openssl x509 -req -sha512 -days 3650 \
    -extfile v3.ext \
    -CA ca.crt -CAkey ca.key -CAcreateserial \
    -in yourdomain.com.csr \
    -out yourdomain.com.crt</code></pre><h5 id="提供证书给Harbor和Docker"><a href="#提供证书给Harbor和Docker" class="headerlink" title="提供证书给Harbor和Docker"></a>提供证书给Harbor和Docker</h5><p>生成后ca.crt，yourdomain.com.crt和yourdomain.com.key文件，必须将它们提供给港口和码头工人，和重新配置港使用它们。</p>
<p>将服务器证书和密钥复制到Harbor主机上的certficates文件夹中。</p>
<pre><code>cp yourdomain.com.crt /data/cert/
cp yourdomain.com.key /data/cert/</code></pre><p>转换yourdomain.com.crt为yourdomain.com.cert，供Docker使用。</p>
<p>Docker守护程序将.crt文件解释为CA证书，并将.cert文件解释为客户端证书。</p>
<pre><code>openssl x509 -inform PEM -in yourdomain.com.crt -out yourdomain.com.cert</code></pre><p>将服务器证书，密钥和CA文件复制到Harbor主机上的Docker certificate文件夹中。必须首先创建适当的文件夹。</p>
<pre><code>cp yourdomain.com.cert /etc/docker/certs.d/yourdomain.com/
cp yourdomain.com.key /etc/docker/certs.d/yourdomain.com/
cp ca.crt /etc/docker/certs.d/yourdomain.com/</code></pre><p>如果将默认nginx端口443 映射到其他端口，请创建文件夹/etc/docker/certs.d/yourdomain.com:port或/etc/docker/certs.d/harbor_IP:port。</p>
<p>重新启动Docker Engine</p>
<pre><code>systemctl restart docker</code></pre><h5 id="添加hosts解析"><a href="#添加hosts解析" class="headerlink" title="添加hosts解析"></a>添加hosts解析</h5><pre><code>echo &quot;10.19.46.15   yourdomain.com&quot; &gt;&gt; /etc/hosts   </code></pre><h4 id="运行prepare脚本以启用HTTPS"><a href="#运行prepare脚本以启用HTTPS" class="headerlink" title="运行prepare脚本以启用HTTPS"></a>运行prepare脚本以启用HTTPS</h4><pre><code>./prepare</code></pre><h5 id="停止harbor"><a href="#停止harbor" class="headerlink" title="停止harbor"></a>停止harbor</h5><pre><code>docker-compose down -v    </code></pre><h5 id="开启harbor"><a href="#开启harbor" class="headerlink" title="开启harbor"></a>开启harbor</h5><pre><code>docker-compose up -d</code></pre><h5 id="本机登录"><a href="#本机登录" class="headerlink" title="本机登录"></a>本机登录</h5><pre><code>[root@JD harbor]# docker login 127.0.0.1:443
Username: admin
Password: 
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded   </code></pre><p><a href="https://goharbor.io/docs/1.10/install-config/quick-install-script/" target="_blank" rel="noopener">部署单机版harbor</a></p>
<p><a href="https://goharbor.io/docs/1.10/install-config/harbor-ha-helm/" target="_blank" rel="noopener">通过Helm部署具有高可用性的harbor</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-使用  Docker Compose  搭建一 个拥有权限认证、TLS 的私有仓库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/01/使用  Docker Compose  搭建一 个拥有权限认证、TLS 的私有仓库/" class="article-date">
  	<time datetime="2020-04-01T15:18:47.318Z" itemprop="datePublished">2020-04-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="准备站点证书"><a href="#准备站点证书" class="headerlink" title="准备站点证书"></a>准备站点证书</h1><p>如果你拥有一个域名，国内各大云服务商均提供免费的站点证书。你也可以使用  openssl  自<br>行签发证书。</p>
<p>这里假设我们将要搭建的私有仓库地址为  docker.domain.com  ，下面我们介绍使用  openssl<br>自行签发  docker.domain.com  的站点 SSL 证书。</p>
<h2 id="第一步创建-CA-私钥。"><a href="#第一步创建-CA-私钥。" class="headerlink" title="第一步创建  CA  私钥。"></a>第一步创建  CA  私钥。</h2><pre><code>$ openssl genrsa -out &quot;root-ca.key&quot; 4096</code></pre><h2 id="第二步利用私钥创建-CA-根证书请求文件。"><a href="#第二步利用私钥创建-CA-根证书请求文件。" class="headerlink" title="第二步利用私钥创建  CA  根证书请求文件。"></a>第二步利用私钥创建  CA  根证书请求文件。</h2><pre><code>$ openssl req \
    -new -key &quot;root-ca.key&quot; \
    -out &quot;root-ca.csr&quot; -sha256 \
    -subj &apos;/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=Your Company Name Doc
    ker Registry CA&apos;</code></pre><p>以上命令中  -subj  参数里的  /C  表示国家，如  CN  ； /ST  表示省； /L  表示城市或者<br>地区； /O  表示组织名； /CN  通用名称。</p>
<h2 id="第三步配置-CA-根证书，新建-root-ca-cnf-。"><a href="#第三步配置-CA-根证书，新建-root-ca-cnf-。" class="headerlink" title="第三步配置  CA  根证书，新建  root-ca.cnf  。"></a>第三步配置  CA  根证书，新建  root-ca.cnf  。</h2><pre><code>[root_ca]
basicConstraints = critical,CA:TRUE,pathlen:1
keyUsage = critical, nonRepudiation, cRLSign, keyCertSign
subjectKeyIdentifier=hash</code></pre><h2 id="第四步签发根证书。"><a href="#第四步签发根证书。" class="headerlink" title="第四步签发根证书。"></a>第四步签发根证书。</h2><pre><code>$ openssl x509 -req -days 3650 -in &quot;root-ca.csr&quot; \
    -signkey &quot;root-ca.key&quot; -sha256 -out &quot;root-ca.crt&quot; \
    -extfile &quot;root-ca.cnf&quot; -extensions \
    root_ca</code></pre><h2 id="第五步生成站点-SSL-私钥。"><a href="#第五步生成站点-SSL-私钥。" class="headerlink" title="第五步生成站点  SSL  私钥。"></a>第五步生成站点  SSL  私钥。</h2><pre><code>$ openssl genrsa -out &quot;docker.domain.com.key&quot; 4096</code></pre><h2 id="第六步使用私钥生成证书请求文件。"><a href="#第六步使用私钥生成证书请求文件。" class="headerlink" title="第六步使用私钥生成证书请求文件。"></a>第六步使用私钥生成证书请求文件。</h2><pre><code>$ openssl req -new -key &quot;docker.domain.com.key&quot; -out &quot;site.csr&quot; -sha256 \
    -subj &apos;/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=docker.domain.com&apos;</code></pre><h2 id="第七步配置证书，新建-site-cnf-文件。"><a href="#第七步配置证书，新建-site-cnf-文件。" class="headerlink" title="第七步配置证书，新建  site.cnf  文件。"></a>第七步配置证书，新建  site.cnf  文件。</h2><pre><code>[server]
authorityKeyIdentifier=keyid,issuer
basicConstraints = critical,CA:FALSE
extendedKeyUsage=serverAuth
keyUsage = critical, digitalSignature, keyEncipherment
subjectAltName = DNS:docker.domain.com, IP:127.0.0.1
subjectKeyIdentifier=hash</code></pre><h2 id="第八步签署站点-SSL-证书。"><a href="#第八步签署站点-SSL-证书。" class="headerlink" title="第八步签署站点  SSL  证书。"></a>第八步签署站点  SSL  证书。</h2><pre><code>$ openssl x509 -req -days 750 -in &quot;site.csr&quot; -sha256 \
    -CA &quot;root-ca.crt&quot; -CAkey &quot;root-ca.key&quot; -CAcreateserial \
    -out &quot;docker.domain.com.crt&quot; -extfile &quot;site.cnf&quot; -extensions server</code></pre><p>这样已经拥有了  docker.domain.com  的网站 SSL 私钥  docker.domain.com.key  和 SSL 证书<br>docker.domain.com.crt  。</p>
<p>新建  ssl  文件夹并将  docker.domain.com.key   docker.domain.com.crt  这两个文件移入，删<br>除其他文件。</p>
<h1 id="配置私有仓库"><a href="#配置私有仓库" class="headerlink" title="配置私有仓库"></a>配置私有仓库</h1><p>私有仓库默认的配置文件位于  /etc/docker/registry/config.yml  ，我们先在本地编辑<br>config.yml  ，之后挂载到容器中。</p>
<pre><code>version: 0.1
log:
    accesslog:
        disabled: true
level: debug
formatter: text
fields:
    service: registry
    environment: staging
storage:
    delete:
        enabled: true
    cache:
        blobdescriptor: inmemory
    filesystem:
        rootdirectory: /var/lib/registry
auth:
    htpasswd:
        realm: basic-realm
        path: /etc/docker/registry/auth/nginx.htpasswd
http:
    addr: :443
    host: https://docker.domain.com
    headers:
        X-Content-Type-Options: [nosniff]
    http2:
        disabled: false
    tls:
        certificate: /etc/docker/registry/ssl/docker.domain.com.crt
        key: /etc/docker/registry/ssl/docker.domain.com.key
health:
    storagedriver:
        enabled: true
        interval: 10s
threshold: 3</code></pre><h2 id="生成-http-认证文件"><a href="#生成-http-认证文件" class="headerlink" title="生成 http 认证文件"></a>生成 http 认证文件</h2><pre><code>$ mkdir auth
$ docker run --rm \
    --entrypoint htpasswd \
    registry \
    -Bbn username password &gt; auth/nginx.htpasswd</code></pre><p>将上面的  username   password  替换为你自己的用户名和密码。</p>
<h2 id="编辑-docker-compose-yml"><a href="#编辑-docker-compose-yml" class="headerlink" title="编辑 docker-compose.yml"></a>编辑 docker-compose.yml</h2><pre><code>version: &apos;3&apos;

services:
    registry:
    image: registry
    ports:
        - &quot;443:443&quot;
    volumes:
        - ./:/etc/docker/registry
        - registry-data:/var/lib/registry
volumes:
    registry-data:</code></pre><h2 id="修改-hosts"><a href="#修改-hosts" class="headerlink" title="修改 hosts"></a>修改 hosts</h2><h3 id="编辑-etc-hosts"><a href="#编辑-etc-hosts" class="headerlink" title="编辑  /etc/hosts"></a>编辑  /etc/hosts</h3><pre><code>docker.domain.com 127.0.0.1</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>$ docker-compose up -d</code></pre><p>这样我们就搭建好了一个具有权限认证、TLS 的私有仓库，接下来我们测试其功能是否正<br>常。</p>
<h1 id="测试私有仓库功能"><a href="#测试私有仓库功能" class="headerlink" title="测试私有仓库功能"></a>测试私有仓库功能</h1><h2 id="登录到私有仓库。"><a href="#登录到私有仓库。" class="headerlink" title="登录到私有仓库。"></a>登录到私有仓库。</h2><pre><code>$ docker login docker.domain.com</code></pre><h2 id="尝试推送、拉取镜像。"><a href="#尝试推送、拉取镜像。" class="headerlink" title="尝试推送、拉取镜像。"></a>尝试推送、拉取镜像。</h2><pre><code>$ docker pull ubuntu:17.10
$ docker tag ubuntu:17.10 docker.domain.com/username/ubuntu:17.10
$ docker push docker.domain.com/username/ubuntu:17.10
$ docker image rm docker.domain.com/username/ubuntu:17.10
$ docker pull docker.domain.com/username/ubuntu:17.10</code></pre><h2 id="如果我们退出登录，尝试推送镜像。"><a href="#如果我们退出登录，尝试推送镜像。" class="headerlink" title="如果我们退出登录，尝试推送镜像。"></a>如果我们退出登录，尝试推送镜像。</h2><pre><code>$ docker logout docker.domain.com
$ docker push docker.domain.com/username/ubuntu:17.10
no basic auth credentials</code></pre><p>发现会提示没有登录，不能将镜像推送到私有仓库中。</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>《Docker技术入门到实践》</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-rocketmq小结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/22/rocketmq小结/" class="article-date">
  	<time datetime="2020-03-22T14:32:57.433Z" itemprop="datePublished">2020-03-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="mq怎么解决重复消费"><a href="#mq怎么解决重复消费" class="headerlink" title="mq怎么解决重复消费"></a>mq怎么解决重复消费</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-redis笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/21/redis笔记/" class="article-date">
  	<time datetime="2020-03-21T02:08:00.022Z" itemprop="datePublished">2020-03-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Redis缓存更新怎么保证⼀致性？"><a href="#Redis缓存更新怎么保证⼀致性？" class="headerlink" title="Redis缓存更新怎么保证⼀致性？"></a>Redis缓存更新怎么保证⼀致性？</h3><p>删缓存-&gt;更新db-&gt;再删缓存</p>
<p>更新db-&gt;删缓存</p>
<p>第一种方案：</p>
<p>使用阿里的canal将binlog日志采集发送到MQ队列里面，然后通过ACK机制确认处理 这条更新消息，删除缓存，保证数据缓存一致性</p>
<pre><code>（1）读取缓存中是否有相关数据
（2）如果缓存中有相关数据value，则返回
（3）如果缓存中没有相关数据，则从数据库读取相关数据放入缓存中key-&gt;value，再返回
（4）如果有更新数据，则先更新数据，再删除缓存
（5）为了保证第四步删除缓存成功，使用binlog异步删除
（6）如果是主从数据库，binglog取自于从库
（7）如果是一主多从，每个从库都要采集binlog，然后消费端收到最后一台binlog数据才删除缓存</code></pre><p><a href="https://juejin.im/post/5d694d336fb9a06aca383493" target="_blank" rel="noopener">高并发环境下，先操作数据库还是先操作缓存</a></p>
<p>第二种方案：</p>
<p><code>使用一致性算法： paxos</code></p>
<h3 id="Redis分布式锁原理？会有什么问题"><a href="#Redis分布式锁原理？会有什么问题" class="headerlink" title="Redis分布式锁原理？会有什么问题"></a>Redis分布式锁原理？会有什么问题</h3><p>redis分布式锁的实现主要是基于redis的<a href="http://doc.redisfans.com/string/setnx.html" target="_blank" rel="noopener">setnx 命令</a></p>
<p>第一种情况：业务逻辑执行时间超出锁的超时限制，其他客户端得到锁之后，被超时客户端删除锁</p>
<pre><code>一个客户端拿到了锁，被某个操作阻塞了很长时间，过了超时时间后自动释放了
这个锁，然后这个客户端之后又尝试删除这个其实已经被其他客户端拿到的锁。
所以单纯的用DEL指令有可能造成一个客户端删除了其他客户端的锁，
通过校验这个值保证每个客户端都用一个随机字符串’签名’了，
这样每个锁就只能被获得锁的客户端删除了。</code></pre><p> 第二种情况：业务逻辑执行时间超出锁的超时限制导致两个客户端同时持有锁的问题</p>
<pre><code>如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，
就会出现问题。因为这时候第一个线程持有的锁过期了，临界区的逻辑还没有
执行完，这个时候第二个线程就提前重新持有了这把锁，导致临界区代码不能
得到严格的串行执行

如果在执行计算期间发现锁快要超时了，客户端可以给redis服务实例发送一个
Lua脚本让redis服务端延长锁的时间，只要这个锁的key还存在而且值还等于
客户端设置的那个值    

if  redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then 
        redis.call(&quot;set&quot;,KEYS[1],ex=3000)
else 
        getDLock();//重新获取锁</code></pre><p>第三种： redis的单点故障主从切换带来的两个客户端同时持有锁的问题</p>
<pre><code>生产中redis一般是主从模式，主节点挂掉时，从节点会取而代之，
客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，
但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。
然后从节点变成了主节点，这个新的节点内部没有这个锁，
所以当另一个客户端过来请求加锁时，立即就批准了。
这样就会导致系统中同样一把锁被两个客户端同时持有

不过这种不安全也仅仅是在主从发生 failover 的情况下才会产生，
而且持续时间极短，业务系统多数情况下可以容忍</code></pre><h2 id="RedLock算法"><a href="#RedLock算法" class="headerlink" title="RedLock算法"></a>RedLock算法</h2><p>使用N个完全独立、没有主从关系的Redis master节点以保证他们大多数情况下都不会同时宕机，N一般为奇数。一个客户端需要做如下操作来获取锁：</p>
<ul>
<li>1.获取当前时间（单位是毫秒）。</li>
<li>2.轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。</li>
<li>3.客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（(N/2) +1），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</li>
<li>4.如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</li>
<li>5.如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。</li>
</ul>
<p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">使用Redis的分布式锁</a></p>
<h1 id="Redis集群⽅案？新增节点后如何进⾏数据迁移。"><a href="#Redis集群⽅案？新增节点后如何进⾏数据迁移。" class="headerlink" title="Redis集群⽅案？新增节点后如何进⾏数据迁移。"></a>Redis集群⽅案？新增节点后如何进⾏数据迁移。</h1><p><a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">Redis Cluster</a></p>
<p>添加一个空节点，然后将一些数据移入该节点（如果它是新的主节点），或者告诉它设置为已知节点的副本（如果它是从节点的话）</p>
<p><code>redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000</code><br>add-node命令将新节点的地址指定为第一个参数，并将集群中随机存在的节点的地址指定为第二个参数.<br>与其他master节点相比：</p>
<pre><code>由于没有分配的`hash slots`，因此不保存任何数据。（可以使用的重新分片功能为此节点分配`hash slots`）
因为它是没有分配`slots`的主机，所以当从机要成为主机时，它不会参与选举过程。</code></pre><p><a href="https://redis.io/topics/cluster-tutorial/#adding-a-new-node" target="_blank" rel="noopener">添加一个新的节点</a></p>
<p><strong>新增节点后如何进⾏数据迁移没有找到相关资料。。。</strong></p>
<h2 id="Redis持久化机制？RDB、AOF，最新的默认⽅案是什么？"><a href="#Redis持久化机制？RDB、AOF，最新的默认⽅案是什么？" class="headerlink" title="Redis持久化机制？RDB、AOF，最新的默认⽅案是什么？"></a>Redis持久化机制？RDB、AOF，最新的默认⽅案是什么？</h2><p>RDB的优点：</p>
<ul>
<li>RDB是Redis数据的非常紧凑的单文件时间点表示。RDB文件非常适合备份。例如，您可能希望在最近的24小时内每小时存档一次RDB文件，并在30天之内每天保存一次RDB快照。这使您可以在发生灾难时轻松还原数据集的不同版本。</li>
<li>RDB对于灾难恢复非常有用，它是一个紧凑的文件，可以传输到远程数据中心或Amazon S3（可能已加密）上。</li>
<li>RDB最大限度地提高了Redis的性能，因为Redis父进程为了持久化所需要做的唯一工作就是分叉一个孩子，其余的都将做。父实例将永远不会执行磁盘I / O或类似操作。</li>
<li>与AOF相比，RDB允许大型数据集更快地重启。</li>
</ul>
<p>RDB的缺点：</p>
<ul>
<li>如果您需要在Redis停止工作（例如断电后）的情况下最大程度地减少数据丢失的机会，则RDB不好。您可以在生成RDB的位置配置不同的保存点（例如，在至少五分钟之后，对数据集进行100次写入，但是您可以有多个保存点）。但是，通常会每隔五分钟或更长时间创建一次RDB快照，因此，如果Redis出于任何原因在没有正确关闭的情况下停止工作，则应该准备丢失最新的数据分钟。</li>
<li>RDB需要经常使用fork（）才能使用子进程将其持久化在磁盘上。如果数据集很大，Fork（）可能很耗时，并且如果数据集很大且CPU性能不佳，则可能导致Redis停止为客户端服务几毫秒甚至一秒钟。AOF还需要fork（），但您可以调整要重写日志的频率，而无需在持久性上进行权衡。</li>
</ul>
<p>AOF的优点：</p>
<ul>
<li>使用AOF Redis更加持久：您可以有不同的fsync策略：完全没有fsync，每秒fsync，每个查询fsync。使用默认策略fsync时，每秒的写入性能仍然很好（fsync是使用后台线程执行的，并且在没有进行fsync的情况下，主线程将尽力执行写入操作。）但是您只能损失一秒钟的写入时间。</li>
<li>AOF日志仅是一个追加日志，因此，如果断电，也不会出现寻道或损坏问题。即使由于某种原因（磁盘已满或其他原因）以半写命令结束日志，redis-check-aof工具也可以轻松修复它。</li>
<li>Redis太大时，Redis可以在后台自动重写AOF。重写是完全安全的，因为Redis继续追加到旧文件时，会生成一个全新的文件，其中包含创建当前数据集所需的最少操作集，一旦准备好第二个文件，Redis会切换这两个文件并开始追加到新的那一个。</li>
<li>AOF以易于理解和解析的格式包含所有操作的日志。您甚至可以轻松导出AOF文件。例如，即使您使用FLUSHALL命令刷新了所有错误文件，如果在此期间未执行任何日志重写操作，您仍然可以保存数据集，只是停止服务器，删除最新命令并重新启动Redis。</li>
</ul>
<p>AOF的缺点：</p>
<ul>
<li>对于相同的数据集，AOF文件通常大于等效的RDB文件。</li>
<li>根据确切的fsync策略，AOF可能比RDB慢。通常，在将fsync设置为每秒的情况下，性能仍然很高，并且在禁用fsync的情况下，即使在高负载下，它也应与RDB一样快。即使在巨大的写负载情况下，RDB仍然能够提供有关最大延迟的更多保证。</li>
<li>过去，我们在特定命令中遇到过罕见的错误（例如，其中一个涉及阻止命令，例如BRPOPLPUSH），导致生成的AOF在重载时无法重现完全相同的数据集。这些错误很少见，我们在测试套件中进行了测试，自动创建了随机的复杂数据集，然后重新加载它们以检查一切是否正常。但是，RDB持久性几乎是不可能的。为了更清楚地说明这一点：Redis AOF通过像MySQL或MongoDB那样增量更新现有状态来工作，而RDB快照一次又一次地创建所有内容，从概念上讲，它更健壮。但是-1）请注意，每次Redis重写AOF时，都会从数据集中包含的实际数据开始重新创建AOF，与始终附加AOF文件（或重写为读取旧AOF而不是读取内存中的数据）相比，提高了对错误的抵抗力。2）我们从未收到过有关真实环境中检测到的AOF损坏的用户报告。<br><a href="http://doc.redisfans.com/topic/persistence.html" target="_blank" rel="noopener">Redis持久化机制</a></li>
</ul>
<p><a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">redis持久化深入</a></p>
<h3 id="Redis缓存过期与淘汰机制是什么？"><a href="#Redis缓存过期与淘汰机制是什么？" class="headerlink" title="Redis缓存过期与淘汰机制是什么？"></a>Redis缓存过期与淘汰机制是什么？</h3><ul>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-enviction（驱逐）：禁止驱逐数据</li>
</ul>
<h2 id="Redis的缓存穿透、缓存击穿是否了解？业界会使⽤什么⽅案？如果缓存⼤规模失效，怎么办？"><a href="#Redis的缓存穿透、缓存击穿是否了解？业界会使⽤什么⽅案？如果缓存⼤规模失效，怎么办？" class="headerlink" title="Redis的缓存穿透、缓存击穿是否了解？业界会使⽤什么⽅案？如果缓存⼤规模失效，怎么办？"></a>Redis的缓存穿透、缓存击穿是否了解？业界会使⽤什么⽅案？如果缓存⼤规模失效，怎么办？</h2><p>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>
<p>解决方案:<br>(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试<br>(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。<br>(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>
<p><a href="https://oss.redislabs.com/redisbloom/#references" target="_blank" rel="noopener">redis bloom</a></p>
<h2 id="使⽤Redis的场景"><a href="#使⽤Redis的场景" class="headerlink" title="使⽤Redis的场景"></a>使⽤Redis的场景</h2><p> 签到，报名，投票： 位图</p>
<pre><code>位图是一个byte数组，可以使用get/set直接设置跟读取整个位图的值，
也可以使用位图操作getbit/setbit等将byte数组当做位数组来处理。
Redis的位数组是自动扩展的，如果设置了阈值且当前超出了阈值会自动将数组进行扩充，
还可以使用bitcount实现快速统计，使用位图查找指令bitpos查找某范围的位图值，
两个指令也可以组合使用对某个范围的位图值进行统计。比如查找一个用户一年中每周末签到数总和。 </code></pre><p>地理位置GEO模块：附近人功能</p>
<h2 id="ZSet底层是如何实现的"><a href="#ZSet底层是如何实现的" class="headerlink" title="ZSet底层是如何实现的"></a>ZSet底层是如何实现的</h2><p><a href="https://www.jianshu.com/p/e5a516831ac2" target="_blank" rel="noopener">ZSet底层是如何实现的</a></p>
<h2 id="HashSet是如何实现的？"><a href="#HashSet是如何实现的？" class="headerlink" title="HashSet是如何实现的？"></a>HashSet是如何实现的？</h2><p>HashSet不能保证元素的顺序，TreeSet中的元素可以按照某个顺序排列。他们的元素都不能重复</p>
<p><a href="https://zhuanlan.zhihu.com/p/80114601" target="_blank" rel="noopener">HashSet是如何实现的</a></p>
<h2 id="redis和zookeeper做分布式锁各有什么优缺点？"><a href="#redis和zookeeper做分布式锁各有什么优缺点？" class="headerlink" title="redis和zookeeper做分布式锁各有什么优缺点？"></a>redis和zookeeper做分布式锁各有什么优缺点？</h2><p>Redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。   </p>
<p>Zookeeper分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。
  </p>
<h2 id="Redis有什么缺点？"><a href="#Redis有什么缺点？" class="headerlink" title="Redis有什么缺点？"></a>Redis有什么缺点？</h2><p>(一)缓存和数据库双写一致性问题<br>(二)缓存雪崩问题<br>(三)缓存击穿问题<br>(四)缓存的并发竞争问题</p>
<p>redis_cluster 不同的key的 set集合数据是在⼀个node还是多个node</p>
<h2 id="为什么说redis能够快速执行"><a href="#为什么说redis能够快速执行" class="headerlink" title="为什么说redis能够快速执行"></a>为什么说redis能够快速执行</h2><pre><code>绝大部分请求是纯粹的内存操作（非常快速）
采用单线程,避免了不必要的上下文切换和竞争条件
非阻塞IO - IO多路复用</code></pre><h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ul>
<li>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li>
<li>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li>
<li>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li>
<li>(4) 尽量避免在压力很大的主库上增加从库 </li>
<li>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</li>
</ul>
<h2 id="为什么Redis不支持回滚"><a href="#为什么Redis不支持回滚" class="headerlink" title="为什么Redis不支持回滚"></a>为什么Redis不支持回滚</h2><p>Redis命令在事务期间可能会失败，但Redis仍将执行事务的其余部分而不是回滚</p>
<ul>
<li><p>仅当使用错误的语法（并且在命令队列期间无法检测到该问题）或针对持有错误数据类型的键调用Redis命令时，该命令才能失败：这实际上意味着失败的命令是编程错误的结果，还有一种很可能在开发过程中而不是生产过程中发现的错误。</p>
</li>
<li><p>Redis在内部得到了简化和更快，因为它不需要回滚的能力。</p>
</li>
<li><p><a href="https://redis.io/topics/transactions#why-redis-does-not-support-roll-backs" target="_blank" rel="noopener">为什么Redis不支持回滚</a></p>
<h2 id="Redis使用epoll异步非阻塞模型-，Redis自身实现了事件处理模型将epoll中的链接、读写、关闭都转换为事件，不在网络IO上浪费过多的事"><a href="#Redis使用epoll异步非阻塞模型-，Redis自身实现了事件处理模型将epoll中的链接、读写、关闭都转换为事件，不在网络IO上浪费过多的事" class="headerlink" title="Redis使用epoll异步非阻塞模型 ，Redis自身实现了事件处理模型将epoll中的链接、读写、关闭都转换为事件，不在网络IO上浪费过多的事"></a>Redis使用epoll异步非阻塞模型 ，Redis自身实现了事件处理模型将epoll中的链接、读写、关闭都转换为事件，不在网络IO上浪费过多的事</h2><p><a href="https://www.cnblogs.com/allenwas3/p/8473614.html" target="_blank" rel="noopener">redis使用epoll</a></p>
<h2 id="升级redis集群节点"><a href="#升级redis集群节点" class="headerlink" title="升级redis集群节点"></a>升级redis集群节点</h2><p>升级从节点：</p>
<p>  停止节点并使用更新版本的Redis重新启动它即可。<br>  如果存在使用从属节点扩展读取的客户端，则在给定的从属节点不可用时，<br>  它们应该能够重新连接到其他从属节点</p>
</li>
</ul>
<p>升级master节点：</p>
<ul>
<li>使用CLUSTER FAILOVER触发主服务器到其从服务器之一的手动故障转移。</li>
<li>等待主机变成从机。</li>
<li>最后，像对从属服务器一样升级节点。</li>
<li>如果要将主节点作为刚刚升级的节点，请触发新的手动故障转移，以将升级后的节点转换回主节点。</li>
</ul>
<p><a href="https://redis.io/topics/cluster-tutorial/#upgrading-nodes-in-a-redis-cluster" target="_blank" rel="noopener">升级redis集群节点</a></p>
<p>##<br>参考资料：</p>
<p><a href="https://blog.csdn.net/qq_42322103/article/details/104159919/" target="_blank" rel="noopener">redis常用命令解析</a></p>
<p><a href="https://redis.io/commands" target="_blank" rel="noopener">redis_commands_list</a></p>
<p><a href="https://redis.io/topics/faq" target="_blank" rel="noopener">redis-FAQ</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-docker小结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/18/docker小结/" class="article-date">
  	<time datetime="2020-03-18T10:43:55.000Z" itemprop="datePublished">2020-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/18/docker小结/">
        docker小结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h1><p>容器在Linux上本地运行，并与其他容器共享主机的内核。它运行一个离散进程，不占用任何其他可执行文件更多的内存，从而使其轻巧。</p>
<p>相比之下，虚拟机（VM）运行具有“ 虚拟机管理程序”对主机资源的虚拟访问权的成熟<code>guest</code>操作系统。通常，VM会产生大量开销，超出了应用程序逻辑所消耗的开销。</p>
<p><img src="//yoursite.com/2020/03/18/docker小结/docker%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="docker和虚拟机"></p>
<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><h2 id="windows下安装docker"><a href="#windows下安装docker" class="headerlink" title="windows下安装docker"></a>windows下安装docker</h2><p><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">在Windows上安装Docker Desktop</a></p>
<p><a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows/" target="_blank" rel="noopener">下载Docker Desktop</a></p>
<h4 id="需要注意的是："><a href="#需要注意的是：" class="headerlink" title="需要注意的是："></a>需要注意的是：</h4><p>运行Docker Desktop需要Microsoft Hyper-V。必要时，Docker桌面Windows安装程序会启用Hyper-V，然后重新启动计算机。启用Hyper-V后，VirtualBox不再起作用。但是，将保留所有现有的VirtualBox VM映像。</p>
<p>用docker-machine（包括default通常在Toolbox安装过程中创建的虚拟机）创建的VirtualBox VM 不再启动。这些VM不能与Docker Desktop并排使用。但是，您仍然可以 docker-machine用来管理远程VM。</p>
<p><a href="https://blog.csdn.net/huryer/article/details/91126391" target="_blank" rel="noopener">安装Docker后VMware和VirtualBox无法启动 VT-x is not available</a></p>
<h2 id="linux下安装docker"><a href="#linux下安装docker" class="headerlink" title="linux下安装docker"></a>linux下安装docker</h2><p>用yum源安装</p>
<p>查看是否已安装docker列表</p>
<pre><code>yum list installed | grep docker</code></pre><p>安装docker</p>
<pre><code>yum -y install docker</code></pre><p>启动docker</p>
<pre><code>systemctl start docker</code></pre><p>查看docker服务状态</p>
<pre><code>systemctl status docker</code></pre><h2 id="配置-加速器"><a href="#配置-加速器" class="headerlink" title="配置 加速器"></a>配置 加速器</h2><p>对于使用 upstart 的系统而言，编辑  /etc/default/docker  文件，在其中的  DOCKER_OPTS  中<br>添加获得的加速器配置：</p>
<pre><code>DOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com&quot;</code></pre><p>重新启动服务。</p>
<pre><code>$ sudo service docker restart</code></pre><p>对于使用 systemd 的系统，请在  /etc/docker/daemon.json  中写入如下内容（如果文件不存<br>在请新建该文件）</p>
<pre><code>{
    &quot;registry-mirrors&quot;: [
        &quot;https://registry.docker-cn.com&quot;
    ]
}</code></pre><p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。<br>之后重新启动服务。</p>
<pre><code>$ sudo systemctl daemon-reload
$ sudo systemctl restart docker    </code></pre><p>​    </p>
<h1 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h1><h2 id="基于dockerfile创建镜像"><a href="#基于dockerfile创建镜像" class="headerlink" title="基于dockerfile创建镜像"></a>基于dockerfile创建镜像</h2><h3 id="编写docker-file"><a href="#编写docker-file" class="headerlink" title="编写docker file"></a>编写docker file</h3><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">dockerfile命令参考</a></p>
<pre><code># Use the official image as a parent image
FROM node:current-slim

# Set the working directory
WORKDIR /usr/src/app

# Copy the file from your host to your current location
COPY package.json .

# Run the command inside your image filesystem
RUN npm install

# Inform Docker that the container is listening on the specified port at runtime.
EXPOSE 8080

# Run the specified command within the container.
CMD [ &quot;npm&quot;, &quot;start&quot; ]

# Copy the rest of your app&apos;s source code from your host to your image filesystem.
COPY . .    </code></pre><h3 id="dockerfile-命令"><a href="#dockerfile-命令" class="headerlink" title="dockerfile 命令"></a>dockerfile 命令</h3><h4 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h4><pre><code>格式
MAINTAINER &lt;name&gt;
指定该dockerfilr文件的维护者信息。</code></pre><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><pre><code>格式：
RUN &lt;command&gt;                             (shell模式)
RUN[&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;]      (exec模式)</code></pre><p>表示当前镜像构建时候运行的命令，如果有确认输入的话，一定要在命令中添加 -v</p>
<p>如果命令较长，那么可以在命令结尾使用 \ 换行</p>
<p>shell模式：类似于 <code>/bin/bash -c command</code></p>
<p>实例：<code>RUN echo hello</code></p>
<p>exec模式：类似于 RUN<code>[&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;command&quot;]</code></p>
<p>实例： <code>RUN[&quot;echo&quot;, &quot;hello&quot;]</code><br>​</p>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><pre><code>格式：EXPOSE &lt;port&gt; [&lt;port&gt;...]</code></pre><p>设置docker容器对外暴露的端口号，docker 为了安全，不会自动对外打开端口，如果需要外部提供访问，还需要启动容器时增加<code>-p</code>或者<code>-P</code>参数对容器的端口进行分配。</p>
<h2 id="基于容器创建镜像"><a href="#基于容器创建镜像" class="headerlink" title="基于容器创建镜像"></a>基于容器创建镜像</h2><p> <code>不要使用  docker commit  定制镜像，定制镜像应该使用  Dockerfile  来完成</code></p>
<p> docker commit :从容器创建一个新的镜像。</p>
<p> 语法</p>
<pre><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></pre><p> OPTIONS说明：</p>
<ul>
<li><p>a :提交的镜像作者；</p>
</li>
<li><p>c :使用Dockerfile指令来创建镜像；</p>
</li>
<li><p>m :提交时的说明文字；</p>
</li>
<li><p>p :在commit时，将容器暂停。   </p>
</li>
</ul>
<p>示例：</p>
<pre><code>[root@JD ~]# docker ps -a |grep mysql
e718ed5b4e32        mysql:5.7                           &quot;docker-entrypoint.s…&quot;   3 weeks ago         Up 3 weeks                 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp                                mysql
[root@JD ~]# docker commit -a &quot;mujia_prince&quot; -m &quot;test docker commit mysql&quot; e718ed5b4e32 my-test-mysql:v1.0
sha256:bb9c07f10ff04f0fa0f486afc07221110029e13ab3dd61bc495b7bd5ad93978f

[root@JD ~]# docker images -a
REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE
my-test-mysql                  v1.0                bb9c07f10ff0        41 seconds ago      437MB
mysql                          5.7                 db39680b63ac        3 months ago        437MB</code></pre><h1 id="搭建镜像仓库"><a href="#搭建镜像仓库" class="headerlink" title="搭建镜像仓库"></a>搭建镜像仓库</h1><p><a href="https://blog.csdn.net/prince_mujia/article/details/105273055" target="_blank" rel="noopener">搭建docker镜像仓库</a></p>
<h1 id="docker-volumes"><a href="#docker-volumes" class="headerlink" title="docker volumes"></a>docker volumes</h1><p><a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">docker volumes</a></p>
<p>-v：把宿主机的/root/data/registry目录绑定到容器/var/lib/registry目录(这个目录是registry容器中存放镜像文件的目录)，来实现数据的持久化；</p>
<p>示例：</p>
<pre><code>docker run -itd -v /root/data/registry:/var/lib/registry -p 5000:5000 --restart=always --name docker-registry registry:latest </code></pre><p>在镜像仓库中推送镜像<code>registry-mysql</code>之后，在<code>/root/data/registry</code>下能找到：</p>
<pre><code>[root@JD repositories]# pwd
/root/data/registry/docker/registry/v2/repositories
[root@JD repositories]# ll
total 0
drwxr-xr-x 5 root root 55 Apr  1 23:32 registry-mysql</code></pre><p>使用  -v  参数时如果本地目录不存在 Docker 会自动为创建一个文件夹，现在使用  –mount  参数时如果本地目录不存在，Docker 会报错</p>
<p>挂载一个本地主机文件作为数据卷</p>
<p>–mount  标记也可以从主机挂载单个文件到容器中</p>
<pre><code>docker run --rm -it \
# -v $HOME/.bash_history:/root/.bash_history \
--mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \
ubuntu:17.10 \
bash</code></pre><p><code>--rm</code> :在Docker容器退出时，默认容器内部的文件系统仍然被保留，以方便调试并保留用户数据。</p>
<p>但是，对于foreground容器，由于其只是在开发调试过程中短期运行，其用户数据并无保留的必要，因而可以在容器启动时设置–rm选项，这样在容器退出时就能够自动清理容器内部的文件系统</p>
<h2 id="docker-volume-container"><a href="#docker-volume-container" class="headerlink" title="docker volume container"></a>docker volume container</h2><h2 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h2><h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h1><p><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">docker compose install</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.24.1, build 1110ad01</span><br></pre></td></tr></table></figure>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="删除已经停止的容器"><a href="#删除已经停止的容器" class="headerlink" title="删除已经停止的容器"></a>删除已经停止的容器</h2><pre><code>$ docker rm [OPTIONS] CONTAINER [CONTAINER...]
docker rm 2d85b99b03b2</code></pre><h2 id="查看镜像、容器、数据卷所占用的空间"><a href="#查看镜像、容器、数据卷所占用的空间" class="headerlink" title="查看镜像、容器、数据卷所占用的空间"></a>查看镜像、容器、数据卷所占用的空间</h2><pre><code>docker system df   </code></pre><h2 id="查看当前宿主机开放了哪些端口"><a href="#查看当前宿主机开放了哪些端口" class="headerlink" title="查看当前宿主机开放了哪些端口"></a>查看当前宿主机开放了哪些端口</h2><pre><code>netstat -tnulp</code></pre><h2 id="查看docker-信息"><a href="#查看docker-信息" class="headerlink" title="查看docker 信息"></a>查看docker 信息</h2><pre><code>docker inspect [image id]</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/go_channel" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/18/golang/go_channel/" class="article-date">
  	<time datetime="2020-03-18T10:43:55.000Z" itemprop="datePublished">2020-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/18/golang/go_channel/">
        go channel小结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://mp.weixin.qq.com/s/MF3o5Jr7h-EiSN8amKW0QA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MF3o5Jr7h-EiSN8amKW0QA</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/go_map" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/18/golang/go_map/" class="article-date">
  	<time datetime="2020-03-18T10:43:55.000Z" itemprop="datePublished">2020-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/18/golang/go_map/">
        go map小结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://mp.weixin.qq.com/s/BGjJt86MhpbSNPgh2CLRKw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/BGjJt86MhpbSNPgh2CLRKw</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/go_上台阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/18/golang/go_上台阶/" class="article-date">
  	<time datetime="2020-03-18T10:43:55.000Z" itemprop="datePublished">2020-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/18/golang/go_上台阶/">
        go上台阶
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#1、上台阶</p>
<p>递归问题</p>
<p><code>https://blog.csdn.net/qq_27068845/article/details/90181340</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/go_函数" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/18/golang/go_函数/" class="article-date">
  	<time datetime="2020-03-18T10:43:55.000Z" itemprop="datePublished">2020-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/18/golang/go_函数/">
        go 函数小结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p><code>go语言中函数的return不是原子操作，在底层分为两层操作</code></p>
<p><code>第一步：返回值赋值</code></p>
<p><code>defer</code></p>
<p><code>第二步：真正的ret返回</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">func f1() int &#123;</span><br><span class="line">    x := 5</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        x++</span><br><span class="line">    &#125;()</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f2() (x int) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        x++</span><br><span class="line">    &#125;()</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f3() (y int) &#123;</span><br><span class="line">    x := 5</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        x++</span><br><span class="line">    &#125;()</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line">func f4() (x int) &#123;</span><br><span class="line">    defer func(x int) &#123;</span><br><span class="line">        x++</span><br><span class="line">    &#125;(x)</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br><span class="line">func f5()(x int)&#123;</span><br><span class="line">    defer func(x int) int&#123;</span><br><span class="line">        x++</span><br><span class="line">        return x</span><br><span class="line">    &#125;(x)</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f6(x int)&#123;</span><br><span class="line">    defer func(x *int)&#123;</span><br><span class="line">        (*x)++</span><br><span class="line">    &#125;(*x)</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(f1())   //5</span><br><span class="line">    fmt.Println(f2())   //6</span><br><span class="line">    fmt.Println(f3())   //5 </span><br><span class="line">    fmt.Println(f4())   //5</span><br><span class="line">    fmt.Println(f5())   //5 </span><br><span class="line">    fmt.Println(f6())   //6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>defer 会将值先赋值到函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">    a := 1</span><br><span class="line">	b := 2</span><br><span class="line">	defer calc(&quot;1&quot;, a, calc(&quot;10&quot;, a, b))</span><br><span class="line">	a = 0</span><br><span class="line">	defer calc(&quot;2&quot;, a, calc(&quot;20&quot;, a, b))</span><br><span class="line">	b = 1</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">func calc(index string, a, b int) int&#123;</span><br><span class="line">	ret := a +b</span><br><span class="line">	fmt.Println(index, a, b, ret)</span><br><span class="line">	// 20 0 1</span><br><span class="line">	// 2 0 1</span><br><span class="line">	// 10 0 1</span><br><span class="line">	// 1 0 1</span><br><span class="line">	return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">10 1 2 3</span><br><span class="line">20 0 2 2</span><br><span class="line">2 0 2 2</span><br><span class="line">1 1 3 4</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func f11(f func())&#123;</span><br><span class="line">	fmt.Println(&quot;this is f1&quot;)</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f22(x, y int) &#123;</span><br><span class="line">	fmt.Println(&quot;this is f2&quot;)</span><br><span class="line">	fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f33(f func(int, int), x, y int) func()&#123;</span><br><span class="line">	tmp := func()&#123;</span><br><span class="line">		f(x, y)</span><br><span class="line">	&#125;</span><br><span class="line">	return tmp</span><br><span class="line">&#125;</span><br><span class="line">//实现f1(f2)</span><br><span class="line">func main()&#123;</span><br><span class="line">    ret := f33(f22, 100, 200)</span><br><span class="line">    	f11(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func adder() func(int) int &#123;</span><br><span class="line">	var x int</span><br><span class="line">	return func(y int) int &#123;</span><br><span class="line">		x += y</span><br><span class="line">		return x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var f = adder()</span><br><span class="line">	fmt.Println(f(10)) //10</span><br><span class="line">	fmt.Println(f(20)) //30</span><br><span class="line">	fmt.Println(f(30)) //60</span><br><span class="line"></span><br><span class="line">	f1 := adder()</span><br><span class="line">	fmt.Println(f1(40)) //40</span><br><span class="line">	fmt.Println(f1(50)) //90</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func calc(base int) (func(int) int, func(int) int) &#123;</span><br><span class="line">	add := func(i int) int &#123;</span><br><span class="line">		base += i</span><br><span class="line">		return base</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sub := func(i int) int &#123;</span><br><span class="line">		base -= i</span><br><span class="line">		return base</span><br><span class="line">	&#125;</span><br><span class="line">	return add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f1, f2 := calc(10)</span><br><span class="line">	fmt.Println(f1(1), f2(2)) //11 9</span><br><span class="line">	fmt.Println(f1(3), f2(4)) //12 8</span><br><span class="line">	fmt.Println(f1(5), f2(6)) //13 7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func calc(index string, a, b int) int &#123;</span><br><span class="line">	ret := a + b</span><br><span class="line">	fmt.Println(index, a, b, ret)</span><br><span class="line">	return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	x := 1</span><br><span class="line">	y := 2</span><br><span class="line">	defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</span><br><span class="line">	x = 10</span><br><span class="line">	defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</span><br><span class="line">	y = 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面代码的输出结果是?</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/go_指针" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/18/golang/go_指针/" class="article-date">
  	<time datetime="2020-03-18T10:43:55.000Z" itemprop="datePublished">2020-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/18/golang/go_指针/">
        go指针小结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   var a int= 20   /* 声明实际变量 */</span><br><span class="line">   var ip *int        /* 声明指针变量 */</span><br><span class="line"></span><br><span class="line">   ip = &amp;a  /* 指针变量的存储地址 */</span><br><span class="line"></span><br><span class="line">   fmt.Printf(&quot;a 变量的地址是: %x\n&quot;, &amp;a  )</span><br><span class="line"></span><br><span class="line">   /* 指针变量的存储地址 */</span><br><span class="line">   fmt.Printf(&quot;ip 变量储存的指针地址: %x\n&quot;, ip )</span><br><span class="line"></span><br><span class="line">   /* 使用指针访问值 */</span><br><span class="line">   fmt.Printf(&quot;*ip 变量的值: %d\n&quot;, *ip )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p>
<p>nil 指针也称为空指针。</p>
<p>nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    var a *int</span><br><span class="line">*a = 100</span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line">运行时异常：</span><br><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line"></span><br><span class="line">var a = new(int)</span><br><span class="line">fmt.Println(a)     //&lt;nil&gt;</span><br><span class="line">fmt.Println(*a)    // 0</span><br><span class="line">*a = 100  </span><br><span class="line">fmt.Println(*a)    //100</span><br></pre></td></tr></table></figure>

<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>###make和new区别</p>
<p>1、都是用来申请内存的。</p>
<p>2、 make只适用于 slice，map和 channle的内存创建，而且他返回的类型就是他们三个类型本身，而不是他们的指针类型，因为他们是引用类型，所以就没有必要返回他们的指针了。</p>
<p>3、 new很少用，一般用来给基本数据类型申请内存， <code>string</code>，<code>int</code>；返回的都是对应的类型的指针(*string, *int)</p>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var m1  map[string]int</span><br><span class="line">	m1 = make(map[string]int, 10)</span><br><span class="line">	m1[&quot;m1&quot;] = 1</span><br><span class="line">	m1[&quot;m2&quot;] = 2</span><br><span class="line"></span><br><span class="line">	fmt.Println(m1)</span><br><span class="line">//若key不存在，则返回0</span><br><span class="line">	fmt.Println(m1[&quot;m3&quot;])  // 0</span><br><span class="line">	</span><br><span class="line">	for k := range m1&#123;</span><br><span class="line">    		fmt.Println(k)</span><br><span class="line">    	&#125;</span><br><span class="line">    	for k, v := range m1&#123;</span><br><span class="line">    		fmt.Println(k, v)</span><br><span class="line">    	&#125;</span><br><span class="line">    	for _, v := range m1&#123;</span><br><span class="line">    		fmt.Println(v)</span><br><span class="line">    	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map-排序"><a href="#map-排序" class="headerlink" title="map 排序"></a>map 排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">var sortMap = make(map[string]int, 100)</span><br><span class="line">var keys = make([]string, 0, 200)</span><br><span class="line">for i := 1; i&lt;100; i++  &#123;</span><br><span class="line">	key := fmt.Sprintf(&quot;student_%02d&quot;, i)</span><br><span class="line">	value := rand.Intn(100)</span><br><span class="line">	sortMap[key] = value</span><br><span class="line">	keys = append(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"></span><br><span class="line">for _, k := range keys &#123;</span><br><span class="line">	fmt.Println(k, sortMap[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###值为map的切片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var s1 = make([]map[string]int, 10, 10)</span><br><span class="line">s1[0] = make(map[string]int, 10)</span><br><span class="line">s1[0][&quot;北京&quot;] = 100</span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">//[map[北京:100] map[] map[] map[] map[] map[] map[] map[] map[] map[]]</span><br></pre></td></tr></table></figure>

<h3 id="值为切片的map"><a href="#值为切片的map" class="headerlink" title="值为切片的map"></a>值为切片的map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var m1 = make(map[string][]int, 10)</span><br><span class="line">m1[&quot;北京&quot;] = make([]int, 10, 10)</span><br><span class="line">m1[&quot;北京&quot;][0] = 1</span><br><span class="line">fmt.Println(m1)</span><br><span class="line"></span><br><span class="line">//map[北京:[1 0 0 0 0 0 0 0 0 0]]</span><br></pre></td></tr></table></figure>

<h2 id="统计一个字符串中每个单词出现的次数，比如”how-do-you-do-“-中-how-1次，do-2次，you-1次"><a href="#统计一个字符串中每个单词出现的次数，比如”how-do-you-do-“-中-how-1次，do-2次，you-1次" class="headerlink" title="统计一个字符串中每个单词出现的次数，比如”how do you do “ 中  how 1次，do 2次，you 1次"></a>统计一个字符串中每个单词出现的次数，比如”how do you do “ 中  how 1次，do 2次，you 1次</h2><pre><code>var map1 = make(map[string]int, 10)
var str1 = &quot;how do you do how do you do how do you do&quot;
var s1 = make([]string, 10, 10)
s1 = strings.Split(str1, &quot; &quot;)
fmt.Println(s1)
for _, item := range s1 {
    value, ok := map1[item]
    fmt.Println(item)
    if ok{
        value ++
        map1[item] = value
    }else {
        map1[item] = 1
    }
}
fmt.Println(map1)</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2020 zhangyong
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>