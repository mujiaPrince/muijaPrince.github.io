<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>zhangyong</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="zhangyong">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="zhangyong">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhangyong">
  
    <link rel="alternative" href="/atom.xml" title="zhangyong" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head></html>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars0.githubusercontent.com/u/39975746?s=400&amp;u=5c82d9ef34c547270f3fbe1d343a296e3ebdce25&amp;v=4" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">zhangyong</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">zhangyong</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars0.githubusercontent.com/u/39975746?s=400&amp;u=5c82d9ef34c547270f3fbe1d343a296e3ebdce25&amp;v=4" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">zhangyong</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-搭建docker镜像仓库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/02/搭建docker镜像仓库/" class="article-date">
  	<time datetime="2020-04-02T08:18:13.854Z" itemprop="datePublished">2020-04-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p><a href="https://docs.docker.com/registry/" target="_blank" rel="noopener">Docker Registry</a></p>
<pre><code>docker run -itd -v /root/data/registry:/var/lib/registry -p 5000:5000 --restart=always --name docker-registry registry:latest </code></pre><p>对于使用  systemd  的系统，请在  /etc/docker/daemon.json  中写入如下内容（如果文件不存<br>在请新建该文件）</p>
<pre><code>{
    &quot;registry-mirror&quot;: [
        &quot;https://registry.docker-cn.com&quot;
    ],
    &quot;insecure-registries&quot;: [
        &quot;192.168.199.100:5000&quot;
    ]
}</code></pre><p>当前镜像tag</p>
<pre><code>[root@JD ~]# docker tag mysql:5.7 127.0.0.1:5000/registry-mysql:5.7</code></pre><p>推送到镜像仓库</p>
<pre><code>[root@JD ~]# docker push 127.0.0.1:5000/registry-mysql</code></pre><p>用  curl  查看仓库中的镜像。</p>
<pre><code>[root@JD ~]# curl 127.0.0.1:5000/v2/_catalog
{&quot;repositories&quot;:[&quot;registry-mysql&quot;]}</code></pre><p> Docker 默认不允许非<code>HTTPS</code>方式推送镜像</p>
<p> <a href="https://blog.csdn.net/prince_mujia/article/details/105272760" target="_blank" rel="noopener">使用  Docker Compose  搭建一个拥有权限认证、TLS 的私有仓库</a></p>
<h2 id="harbor"><a href="#harbor" class="headerlink" title="harbor"></a>harbor</h2><h4 id="使用脚本搭建"><a href="#使用脚本搭建" class="headerlink" title="使用脚本搭建"></a>使用脚本搭建</h4><p>将harbor.sh脚本从 <a href="https://gist.github.com/kacole2/95e83ac84fec950b1a70b0853d6594dc" target="_blank" rel="noopener">GitHub Gist</a>下载到您的Ubuntu机器或VM。</p>
<p>harbor.sh脚本需要梯子才能下载。我在CSDN上传了一份<code>harbor：v1.10</code>版本的脚本。<br><a href="https://download.csdn.net/download/prince_mujia/12294781" target="_blank" rel="noopener">使用安装脚本快速部署Harbor的脚本文件-harbor.sh</a></p>
<p>向当前用户授予运行权限。</p>
<pre><code>chmod u+x</code></pre><p>要注意修改脚本中的端口号。</p>
<p>Harbor要求在目标主机上打开以下端口。</p>
<table>
<thead>
<tr>
<th align="left">港口</th>
<th align="left">协议</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">443</td>
<td align="left">HTTPS</td>
<td align="left">Harbor门户和核心API在此端口上接受HTTPS请求。您可以在配置文件中更改此端口。</td>
</tr>
<tr>
<td align="left">4443</td>
<td align="left">HTTPS</td>
<td align="left">与Harbor的Docker内容信任服务的连接。仅在启用公证人的情况下才需要。您可以在配置文件中更改此端口。</td>
</tr>
<tr>
<td align="left">80</td>
<td align="left">HTTP</td>
<td align="left">Harbor门户和核心API在此端口上接受HTTP请求。您可以在配置文件中更改此端口。</td>
</tr>
</tbody></table>
<p>以超级用户身份运行脚本。</p>
<pre><code>sudo ./harbor.sh</code></pre><p>选择是使用主机的IP地址还是FQDN部署Harbor。</p>
<pre><code>Would you like to install Harbor based on IP or FQDN?</code></pre><p>这是您访问Harbor接口和注册表服务的地址。</p>
<pre><code>要使用IP地址，请输入1。
要使用FQDN，请输入2。</code></pre><p>该脚本需要几分钟才能运行。在运行时，该脚本会从Ubuntu下载所需的软件包和依赖项，安装最新的稳定版本的Docker和Docker Compose，并安装最新的稳定版本的Harbor。</p>
<p>当脚本报告时Harbor Installation Complete，登录到新的Harbor实例。</p>
<pre><code>docker login &lt;harbor_ip_or_FQDN&gt;
用户名： admin
密码： VMware12345</code></pre><p>在浏览器中输入Harbor地址，以登录Harbor接口</p>
<h2 id="使用harbor-yml搭建"><a href="#使用harbor-yml搭建" class="headerlink" title="使用harbor.yml搭建"></a>使用harbor.yml搭建</h2><p><a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener">harbor 下载</a></p>
<h3 id="解压之后修改harbor-yml"><a href="#解压之后修改harbor-yml" class="headerlink" title="解压之后修改harbor.yml"></a>解压之后修改harbor.yml</h3><p><a href="https://goharbor.io/docs/1.10/install-config/configure-yml-file/" target="_blank" rel="noopener">配置YML文件</a></p>
<pre><code>hostname   这里设置本机的ip
harbor_admin_password    web页面的密码,默认的用户名和密码为admin和Harbor12345</code></pre><p>如果没有https，则需要先注释：</p>
<pre><code>https:
  # https port for harbor, default is 443
  port: 443
  # The path of cert and key files for nginx
  certificate: /your/certificate/path
  private_key: /your/private/key/path</code></pre><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><pre><code>sh ./install.sh

Creating harbor-log ... done
Creating registry      ... done
Creating harbor-db     ... done
Creating harbor-portal ... done
Creating redis         ... done
Creating registryctl   ... done
Creating harbor-core   ... done
Creating harbor-jobservice ... done
Creating nginx             ... done
✔ ----Harbor has been installed and started successfully.----</code></pre><h3 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h3><p><a href="https://114.67.79.102:8088" target="_blank" rel="noopener">https://114.67.79.102:8088</a></p>
<p><img src="docker%E5%B0%8F%E7%BB%93/docker-harbor%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt></p>
<h3 id="建立https访问"><a href="#建立https访问" class="headerlink" title="建立https访问"></a>建立https访问</h3><h4 id="生成证书颁发机构证书"><a href="#生成证书颁发机构证书" class="headerlink" title="生成证书颁发机构证书"></a>生成证书颁发机构证书</h4><h5 id="生成CA证书私钥。"><a href="#生成CA证书私钥。" class="headerlink" title="生成CA证书私钥。"></a>生成CA证书私钥。</h5><pre><code>openssl genrsa -out ca.key 4096</code></pre><h5 id="生成CA证书。"><a href="#生成CA证书。" class="headerlink" title="生成CA证书。"></a>生成CA证书。</h5><p>调整-subj选项中的值以反映您的组织。如果使用FQDN连接Harbor主机，则必须将其指定为通用名称（CN）属性。</p>
<pre><code>openssl req -x509 -new -nodes -sha512 -days 3650 \
 -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=yourdomain.com&quot; \
 -key ca.key \
 -out ca.crt</code></pre><h4 id="生成服务器证书"><a href="#生成服务器证书" class="headerlink" title="生成服务器证书"></a>生成服务器证书</h4><p>证书通常包含一个.crt文件和一个.key文件，例如10.19.46.15.crt和10.19.46.15.key。</p>
<h5 id="生成私钥。"><a href="#生成私钥。" class="headerlink" title="生成私钥。"></a>生成私钥。</h5><pre><code>openssl genrsa -out 10.19.46.15.key 4096</code></pre><h5 id="生成证书签名请求（CSR）。"><a href="#生成证书签名请求（CSR）。" class="headerlink" title="生成证书签名请求（CSR）。"></a>生成证书签名请求（CSR）。</h5><p>调整-subj选项中的值以反映您的组织。如果使用FQDN连接Harbor主机，则必须将其指定为公用名（CN）属性，并在密钥和CSR文件名中使用它。</p>
<pre><code>openssl req -sha512 -new \
    -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=yourdomain.com&quot; \
    -key yourdomain.com.key \
    -out yourdomain.com.csr</code></pre><h5 id="生成一个x509-v3扩展文件。"><a href="#生成一个x509-v3扩展文件。" class="headerlink" title="生成一个x509 v3扩展文件。"></a>生成一个x509 v3扩展文件。</h5><p>无论您使用FQDN还是IP地址连接到Harbor主机，都必须创建此文件，以便可以为您的Harbor主机生成符合主题备用名称（SAN）和x509 v3的证书扩展要求。替换DNS条目以反映您的域。</p>
<pre><code>cat &gt; v3.ext &lt;&lt;-EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1=yourdomain.com
DNS.2=yourdomain
DNS.3=hostname
EOF</code></pre><h5 id="使用该v3-ext文件为您的Harbor主机生成证书。"><a href="#使用该v3-ext文件为您的Harbor主机生成证书。" class="headerlink" title="使用该v3.ext文件为您的Harbor主机生成证书。"></a>使用该v3.ext文件为您的Harbor主机生成证书。</h5><p>将yourdomain.comCRS和CRT文件名中的替换为Harbor主机名。</p>
<pre><code>openssl x509 -req -sha512 -days 3650 \
    -extfile v3.ext \
    -CA ca.crt -CAkey ca.key -CAcreateserial \
    -in yourdomain.com.csr \
    -out yourdomain.com.crt</code></pre><h5 id="提供证书给Harbor和Docker"><a href="#提供证书给Harbor和Docker" class="headerlink" title="提供证书给Harbor和Docker"></a>提供证书给Harbor和Docker</h5><p>生成后ca.crt，yourdomain.com.crt和yourdomain.com.key文件，必须将它们提供给港口和码头工人，和重新配置港使用它们。</p>
<p>将服务器证书和密钥复制到Harbor主机上的certficates文件夹中。</p>
<pre><code>cp yourdomain.com.crt /data/cert/
cp yourdomain.com.key /data/cert/</code></pre><p>转换yourdomain.com.crt为yourdomain.com.cert，供Docker使用。</p>
<p>Docker守护程序将.crt文件解释为CA证书，并将.cert文件解释为客户端证书。</p>
<pre><code>openssl x509 -inform PEM -in yourdomain.com.crt -out yourdomain.com.cert</code></pre><p>将服务器证书，密钥和CA文件复制到Harbor主机上的Docker certificate文件夹中。必须首先创建适当的文件夹。</p>
<pre><code>cp yourdomain.com.cert /etc/docker/certs.d/yourdomain.com/
cp yourdomain.com.key /etc/docker/certs.d/yourdomain.com/
cp ca.crt /etc/docker/certs.d/yourdomain.com/</code></pre><p>如果将默认nginx端口443 映射到其他端口，请创建文件夹/etc/docker/certs.d/yourdomain.com:port或/etc/docker/certs.d/harbor_IP:port。</p>
<p>重新启动Docker Engine</p>
<pre><code>systemctl restart docker</code></pre><h5 id="添加hosts解析"><a href="#添加hosts解析" class="headerlink" title="添加hosts解析"></a>添加hosts解析</h5><pre><code>echo &quot;10.19.46.15   yourdomain.com&quot; &gt;&gt; /etc/hosts   </code></pre><h4 id="运行prepare脚本以启用HTTPS"><a href="#运行prepare脚本以启用HTTPS" class="headerlink" title="运行prepare脚本以启用HTTPS"></a>运行prepare脚本以启用HTTPS</h4><pre><code>./prepare</code></pre><h5 id="停止harbor"><a href="#停止harbor" class="headerlink" title="停止harbor"></a>停止harbor</h5><pre><code>docker-compose down -v    </code></pre><h5 id="开启harbor"><a href="#开启harbor" class="headerlink" title="开启harbor"></a>开启harbor</h5><pre><code>docker-compose up -d</code></pre><h5 id="本机登录"><a href="#本机登录" class="headerlink" title="本机登录"></a>本机登录</h5><pre><code>[root@JD harbor]# docker login 127.0.0.1:443
Username: admin
Password: 
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded   </code></pre><p><a href="https://goharbor.io/docs/1.10/install-config/quick-install-script/" target="_blank" rel="noopener">部署单机版harbor</a></p>
<p><a href="https://goharbor.io/docs/1.10/install-config/harbor-ha-helm/" target="_blank" rel="noopener">通过Helm部署具有高可用性的harbor</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-使用  Docker Compose  搭建一 个拥有权限认证、TLS 的私有仓库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/01/使用  Docker Compose  搭建一 个拥有权限认证、TLS 的私有仓库/" class="article-date">
  	<time datetime="2020-04-01T15:18:47.318Z" itemprop="datePublished">2020-04-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="准备站点证书"><a href="#准备站点证书" class="headerlink" title="准备站点证书"></a>准备站点证书</h1><p>如果你拥有一个域名，国内各大云服务商均提供免费的站点证书。你也可以使用  openssl  自<br>行签发证书。</p>
<p>这里假设我们将要搭建的私有仓库地址为  docker.domain.com  ，下面我们介绍使用  openssl<br>自行签发  docker.domain.com  的站点 SSL 证书。</p>
<h2 id="第一步创建-CA-私钥。"><a href="#第一步创建-CA-私钥。" class="headerlink" title="第一步创建  CA  私钥。"></a>第一步创建  CA  私钥。</h2><pre><code>$ openssl genrsa -out &quot;root-ca.key&quot; 4096</code></pre><h2 id="第二步利用私钥创建-CA-根证书请求文件。"><a href="#第二步利用私钥创建-CA-根证书请求文件。" class="headerlink" title="第二步利用私钥创建  CA  根证书请求文件。"></a>第二步利用私钥创建  CA  根证书请求文件。</h2><pre><code>$ openssl req \
    -new -key &quot;root-ca.key&quot; \
    -out &quot;root-ca.csr&quot; -sha256 \
    -subj &apos;/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=Your Company Name Doc
    ker Registry CA&apos;</code></pre><p>以上命令中  -subj  参数里的  /C  表示国家，如  CN  ； /ST  表示省； /L  表示城市或者<br>地区； /O  表示组织名； /CN  通用名称。</p>
<h2 id="第三步配置-CA-根证书，新建-root-ca-cnf-。"><a href="#第三步配置-CA-根证书，新建-root-ca-cnf-。" class="headerlink" title="第三步配置  CA  根证书，新建  root-ca.cnf  。"></a>第三步配置  CA  根证书，新建  root-ca.cnf  。</h2><pre><code>[root_ca]
basicConstraints = critical,CA:TRUE,pathlen:1
keyUsage = critical, nonRepudiation, cRLSign, keyCertSign
subjectKeyIdentifier=hash</code></pre><h2 id="第四步签发根证书。"><a href="#第四步签发根证书。" class="headerlink" title="第四步签发根证书。"></a>第四步签发根证书。</h2><pre><code>$ openssl x509 -req -days 3650 -in &quot;root-ca.csr&quot; \
    -signkey &quot;root-ca.key&quot; -sha256 -out &quot;root-ca.crt&quot; \
    -extfile &quot;root-ca.cnf&quot; -extensions \
    root_ca</code></pre><h2 id="第五步生成站点-SSL-私钥。"><a href="#第五步生成站点-SSL-私钥。" class="headerlink" title="第五步生成站点  SSL  私钥。"></a>第五步生成站点  SSL  私钥。</h2><pre><code>$ openssl genrsa -out &quot;docker.domain.com.key&quot; 4096</code></pre><h2 id="第六步使用私钥生成证书请求文件。"><a href="#第六步使用私钥生成证书请求文件。" class="headerlink" title="第六步使用私钥生成证书请求文件。"></a>第六步使用私钥生成证书请求文件。</h2><pre><code>$ openssl req -new -key &quot;docker.domain.com.key&quot; -out &quot;site.csr&quot; -sha256 \
    -subj &apos;/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=docker.domain.com&apos;</code></pre><h2 id="第七步配置证书，新建-site-cnf-文件。"><a href="#第七步配置证书，新建-site-cnf-文件。" class="headerlink" title="第七步配置证书，新建  site.cnf  文件。"></a>第七步配置证书，新建  site.cnf  文件。</h2><pre><code>[server]
authorityKeyIdentifier=keyid,issuer
basicConstraints = critical,CA:FALSE
extendedKeyUsage=serverAuth
keyUsage = critical, digitalSignature, keyEncipherment
subjectAltName = DNS:docker.domain.com, IP:127.0.0.1
subjectKeyIdentifier=hash</code></pre><h2 id="第八步签署站点-SSL-证书。"><a href="#第八步签署站点-SSL-证书。" class="headerlink" title="第八步签署站点  SSL  证书。"></a>第八步签署站点  SSL  证书。</h2><pre><code>$ openssl x509 -req -days 750 -in &quot;site.csr&quot; -sha256 \
    -CA &quot;root-ca.crt&quot; -CAkey &quot;root-ca.key&quot; -CAcreateserial \
    -out &quot;docker.domain.com.crt&quot; -extfile &quot;site.cnf&quot; -extensions server</code></pre><p>这样已经拥有了  docker.domain.com  的网站 SSL 私钥  docker.domain.com.key  和 SSL 证书<br>docker.domain.com.crt  。</p>
<p>新建  ssl  文件夹并将  docker.domain.com.key   docker.domain.com.crt  这两个文件移入，删<br>除其他文件。</p>
<h1 id="配置私有仓库"><a href="#配置私有仓库" class="headerlink" title="配置私有仓库"></a>配置私有仓库</h1><p>私有仓库默认的配置文件位于  /etc/docker/registry/config.yml  ，我们先在本地编辑<br>config.yml  ，之后挂载到容器中。</p>
<pre><code>version: 0.1
log:
    accesslog:
        disabled: true
level: debug
formatter: text
fields:
    service: registry
    environment: staging
storage:
    delete:
        enabled: true
    cache:
        blobdescriptor: inmemory
    filesystem:
        rootdirectory: /var/lib/registry
auth:
    htpasswd:
        realm: basic-realm
        path: /etc/docker/registry/auth/nginx.htpasswd
http:
    addr: :443
    host: https://docker.domain.com
    headers:
        X-Content-Type-Options: [nosniff]
    http2:
        disabled: false
    tls:
        certificate: /etc/docker/registry/ssl/docker.domain.com.crt
        key: /etc/docker/registry/ssl/docker.domain.com.key
health:
    storagedriver:
        enabled: true
        interval: 10s
threshold: 3</code></pre><h2 id="生成-http-认证文件"><a href="#生成-http-认证文件" class="headerlink" title="生成 http 认证文件"></a>生成 http 认证文件</h2><pre><code>$ mkdir auth
$ docker run --rm \
    --entrypoint htpasswd \
    registry \
    -Bbn username password &gt; auth/nginx.htpasswd</code></pre><p>将上面的  username   password  替换为你自己的用户名和密码。</p>
<h2 id="编辑-docker-compose-yml"><a href="#编辑-docker-compose-yml" class="headerlink" title="编辑 docker-compose.yml"></a>编辑 docker-compose.yml</h2><pre><code>version: &apos;3&apos;

services:
    registry:
    image: registry
    ports:
        - &quot;443:443&quot;
    volumes:
        - ./:/etc/docker/registry
        - registry-data:/var/lib/registry
volumes:
    registry-data:</code></pre><h2 id="修改-hosts"><a href="#修改-hosts" class="headerlink" title="修改 hosts"></a>修改 hosts</h2><h3 id="编辑-etc-hosts"><a href="#编辑-etc-hosts" class="headerlink" title="编辑  /etc/hosts"></a>编辑  /etc/hosts</h3><pre><code>docker.domain.com 127.0.0.1</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>$ docker-compose up -d</code></pre><p>这样我们就搭建好了一个具有权限认证、TLS 的私有仓库，接下来我们测试其功能是否正<br>常。</p>
<h1 id="测试私有仓库功能"><a href="#测试私有仓库功能" class="headerlink" title="测试私有仓库功能"></a>测试私有仓库功能</h1><h2 id="登录到私有仓库。"><a href="#登录到私有仓库。" class="headerlink" title="登录到私有仓库。"></a>登录到私有仓库。</h2><pre><code>$ docker login docker.domain.com</code></pre><h2 id="尝试推送、拉取镜像。"><a href="#尝试推送、拉取镜像。" class="headerlink" title="尝试推送、拉取镜像。"></a>尝试推送、拉取镜像。</h2><pre><code>$ docker pull ubuntu:17.10
$ docker tag ubuntu:17.10 docker.domain.com/username/ubuntu:17.10
$ docker push docker.domain.com/username/ubuntu:17.10
$ docker image rm docker.domain.com/username/ubuntu:17.10
$ docker pull docker.domain.com/username/ubuntu:17.10</code></pre><h2 id="如果我们退出登录，尝试推送镜像。"><a href="#如果我们退出登录，尝试推送镜像。" class="headerlink" title="如果我们退出登录，尝试推送镜像。"></a>如果我们退出登录，尝试推送镜像。</h2><pre><code>$ docker logout docker.domain.com
$ docker push docker.domain.com/username/ubuntu:17.10
no basic auth credentials</code></pre><p>发现会提示没有登录，不能将镜像推送到私有仓库中。</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>《Docker技术入门到实践》</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-mysql/mysql使用存储过程脚本批量插入数据" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/27/mysql/mysql使用存储过程脚本批量插入数据/" class="article-date">
  	<time datetime="2020-03-27T15:47:51.392Z" itemprop="datePublished">2020-03-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="使用存储过程脚本批量插入数据"><a href="#使用存储过程脚本批量插入数据" class="headerlink" title="使用存储过程脚本批量插入数据"></a>使用存储过程脚本批量插入数据</h1><h3 id="创建数据库表："><a href="#创建数据库表：" class="headerlink" title="创建数据库表："></a>创建数据库表：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE bigtables (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `number` int(20) DEFAULT NULL,</span><br><span class="line">  `name` varchar(100) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<h3 id="创建函数："><a href="#创建函数：" class="headerlink" title="创建函数："></a>创建函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create function rand_string(n int) returns varchar(255)</span><br><span class="line">begin</span><br><span class="line">   declare chars_str varchar(100) default &apos;qwertyuiopasdfghjklzxcvbnm&apos;;</span><br><span class="line">   declare return_str varchar(255) default &apos;&apos;;</span><br><span class="line">   declare i int default 0;   </span><br><span class="line">   while i&lt;n do</span><br><span class="line">   set return_str=concat(return_str,substring(chars_str,floor(1+rand()*52),1));</span><br><span class="line">   set i=i+1;   </span><br><span class="line">   end while;   </span><br><span class="line">   return return_str; </span><br><span class="line">   end $$</span><br></pre></td></tr></table></figure>

<h3 id="创建产生随机的数字的函数"><a href="#创建产生随机的数字的函数" class="headerlink" title="创建产生随机的数字的函数"></a>创建产生随机的数字的函数</h3><p> 删除函数： <code>DROP  FUNCTION rand_num;</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create <span class="function"><span class="keyword">function</span> <span class="title">rand_num</span><span class="params">()</span> <span class="title">returns</span> <span class="title">int</span><span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">i</span> <span class="title">int</span> <span class="title">default</span> 0</span>;</span><br><span class="line">set i=floor(<span class="number">100</span>+rand()*<span class="number">10</span>); </span><br><span class="line"><span class="keyword">return</span> i; end $$</span><br></pre></td></tr></table></figure>

<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>删除存储过程： <code>drop procedure  insert_bigtables;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$ </span><br><span class="line"><span class="function">create procedure <span class="title">insert_bigtables</span><span class="params">(in start <span class="keyword">int</span>(<span class="number">10</span>),in max_num <span class="keyword">int</span>(<span class="number">10</span>))</span></span></span><br><span class="line"><span class="function">begin </span></span><br><span class="line"><span class="function">declare i <span class="keyword">int</span>  <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="built_in">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line">repeat </span><br><span class="line"><span class="built_in">set</span> i = i +<span class="number">1</span>;</span><br><span class="line"><span class="function">insert into <span class="title">bigtables</span><span class="params">(id,number,name)</span> <span class="title">values</span><span class="params">((start+i),rand_num(),rand_string(<span class="number">6</span>))</span></span>;</span><br><span class="line">until i=max_num</span><br><span class="line">end repeat;</span><br><span class="line">commit;</span><br><span class="line">end $$</span><br></pre></td></tr></table></figure>

<h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a><strong>调用存储过程</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">call <span class="title">insert_bigtables</span><span class="params">(<span class="number">100</span>,<span class="number">10</span>)</span></span>; </span><br><span class="line"><span class="comment">/*number大于100，插入10条数据*/</span></span><br></pre></td></tr></table></figure>

<h3 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h3><p><code>select name from mysql.proc where db = &#39;insert_bigtables&#39; and type = &#39;PROCEDURE&#39;;</code></p>
<p><code>SELECT * FROM information_schema.Routines WHERE  ROUTINE_NAME = &#39;insert_bigtables&#39; ;</code></p>
<p><code>SHOW CREATE PROCEDURE insert_bigtables;</code></p>
<p><code>SHOW CREATE FUNCTION rand_num;</code></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-rocketmq小结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/22/rocketmq小结/" class="article-date">
  	<time datetime="2020-03-22T14:32:57.433Z" itemprop="datePublished">2020-03-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="mq怎么解决重复消费"><a href="#mq怎么解决重复消费" class="headerlink" title="mq怎么解决重复消费"></a>mq怎么解决重复消费</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-mysql/mysql面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/21/mysql/mysql面试题/" class="article-date">
  	<time datetime="2020-03-21T02:39:09.415Z" itemprop="datePublished">2020-03-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>mysql为什么强制⾃增主键<br>mysql是怎么保证事务的<br>limit 20000 加载很慢怎么解决<br>字段B、C联合索引，如果where C=1 and B=2;<br>字符串索引变⻓；</p>
<p>事务是怎么做的？@Transactional注解，事务失效场景？⽐如：A⽅法包含查<br>询、更新操作，B⽅法调⽤了A⽅法？事务嵌套问题？事务的传播机制。<br>required、support、require_new、manodory、not_support、<br>sql查询经历了什么？<br>聚集索引和⾮聚集索引有何区别？<br>表：name、age、sex，索引index（name,age,sex)<br>mysql默认的事务隔离级别？是否有幻读？如何解决幻读？Mysql有哪些锁？<br>MVCC是什么？</p>
<p>mysql的数据库隔离级别？默认是什么隔离级别？</p>
<p>mysql 聚集索引叶⼦节点存储的是什么？<br>线程池中的核⼼线程数是怎么设置的？⼜怎么根据运⾏情况调整的？<br>Java中有哪些线程安全的机制？<br>mysql查询优化举例？</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-redis笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/21/redis笔记/" class="article-date">
  	<time datetime="2020-03-21T02:08:00.022Z" itemprop="datePublished">2020-03-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Redis缓存更新怎么保证⼀致性？"><a href="#Redis缓存更新怎么保证⼀致性？" class="headerlink" title="Redis缓存更新怎么保证⼀致性？"></a>Redis缓存更新怎么保证⼀致性？</h3><p>删缓存-&gt;更新db-&gt;再删缓存</p>
<p>更新db-&gt;删缓存</p>
<p>第一种方案：</p>
<p>使用阿里的canal将binlog日志采集发送到MQ队列里面，然后通过ACK机制确认处理 这条更新消息，删除缓存，保证数据缓存一致性</p>
<pre><code>（1）读取缓存中是否有相关数据
（2）如果缓存中有相关数据value，则返回
（3）如果缓存中没有相关数据，则从数据库读取相关数据放入缓存中key-&gt;value，再返回
（4）如果有更新数据，则先更新数据，再删除缓存
（5）为了保证第四步删除缓存成功，使用binlog异步删除
（6）如果是主从数据库，binglog取自于从库
（7）如果是一主多从，每个从库都要采集binlog，然后消费端收到最后一台binlog数据才删除缓存</code></pre><p><a href="https://juejin.im/post/5d694d336fb9a06aca383493" target="_blank" rel="noopener">高并发环境下，先操作数据库还是先操作缓存</a></p>
<p>第二种方案：</p>
<p><code>使用一致性算法： paxos</code></p>
<h3 id="Redis分布式锁原理？会有什么问题"><a href="#Redis分布式锁原理？会有什么问题" class="headerlink" title="Redis分布式锁原理？会有什么问题"></a>Redis分布式锁原理？会有什么问题</h3><p>redis分布式锁的实现主要是基于redis的<a href="http://doc.redisfans.com/string/setnx.html" target="_blank" rel="noopener">setnx 命令</a></p>
<p>第一种情况：业务逻辑执行时间超出锁的超时限制，其他客户端得到锁之后，被超时客户端删除锁</p>
<pre><code>一个客户端拿到了锁，被某个操作阻塞了很长时间，过了超时时间后自动释放了
这个锁，然后这个客户端之后又尝试删除这个其实已经被其他客户端拿到的锁。
所以单纯的用DEL指令有可能造成一个客户端删除了其他客户端的锁，
通过校验这个值保证每个客户端都用一个随机字符串’签名’了，
这样每个锁就只能被获得锁的客户端删除了。</code></pre><p> 第二种情况：业务逻辑执行时间超出锁的超时限制导致两个客户端同时持有锁的问题</p>
<pre><code>如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，
就会出现问题。因为这时候第一个线程持有的锁过期了，临界区的逻辑还没有
执行完，这个时候第二个线程就提前重新持有了这把锁，导致临界区代码不能
得到严格的串行执行

如果在执行计算期间发现锁快要超时了，客户端可以给redis服务实例发送一个
Lua脚本让redis服务端延长锁的时间，只要这个锁的key还存在而且值还等于
客户端设置的那个值    

if  redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then 
        redis.call(&quot;set&quot;,KEYS[1],ex=3000)
else 
        getDLock();//重新获取锁</code></pre><p>第三种： redis的单点故障主从切换带来的两个客户端同时持有锁的问题</p>
<pre><code>生产中redis一般是主从模式，主节点挂掉时，从节点会取而代之，
客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，
但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。
然后从节点变成了主节点，这个新的节点内部没有这个锁，
所以当另一个客户端过来请求加锁时，立即就批准了。
这样就会导致系统中同样一把锁被两个客户端同时持有

不过这种不安全也仅仅是在主从发生 failover 的情况下才会产生，
而且持续时间极短，业务系统多数情况下可以容忍</code></pre><h2 id="RedLock算法"><a href="#RedLock算法" class="headerlink" title="RedLock算法"></a>RedLock算法</h2><p>使用N个完全独立、没有主从关系的Redis master节点以保证他们大多数情况下都不会同时宕机，N一般为奇数。一个客户端需要做如下操作来获取锁：</p>
<ul>
<li>1.获取当前时间（单位是毫秒）。</li>
<li>2.轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。</li>
<li>3.客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（(N/2) +1），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</li>
<li>4.如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</li>
<li>5.如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。</li>
</ul>
<p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">使用Redis的分布式锁</a></p>
<h1 id="Redis集群⽅案？新增节点后如何进⾏数据迁移。"><a href="#Redis集群⽅案？新增节点后如何进⾏数据迁移。" class="headerlink" title="Redis集群⽅案？新增节点后如何进⾏数据迁移。"></a>Redis集群⽅案？新增节点后如何进⾏数据迁移。</h1><p><a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">Redis Cluster</a></p>
<p>添加一个空节点，然后将一些数据移入该节点（如果它是新的主节点），或者告诉它设置为已知节点的副本（如果它是从节点的话）</p>
<p><code>redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000</code><br>add-node命令将新节点的地址指定为第一个参数，并将集群中随机存在的节点的地址指定为第二个参数.<br>与其他master节点相比：</p>
<pre><code>由于没有分配的`hash slots`，因此不保存任何数据。（可以使用的重新分片功能为此节点分配`hash slots`）
因为它是没有分配`slots`的主机，所以当从机要成为主机时，它不会参与选举过程。</code></pre><p><a href="https://redis.io/topics/cluster-tutorial/#adding-a-new-node" target="_blank" rel="noopener">添加一个新的节点</a></p>
<p><strong>新增节点后如何进⾏数据迁移没有找到相关资料。。。</strong></p>
<h2 id="Redis持久化机制？RDB、AOF，最新的默认⽅案是什么？"><a href="#Redis持久化机制？RDB、AOF，最新的默认⽅案是什么？" class="headerlink" title="Redis持久化机制？RDB、AOF，最新的默认⽅案是什么？"></a>Redis持久化机制？RDB、AOF，最新的默认⽅案是什么？</h2><p>RDB的优点：</p>
<ul>
<li>RDB是Redis数据的非常紧凑的单文件时间点表示。RDB文件非常适合备份。例如，您可能希望在最近的24小时内每小时存档一次RDB文件，并在30天之内每天保存一次RDB快照。这使您可以在发生灾难时轻松还原数据集的不同版本。</li>
<li>RDB对于灾难恢复非常有用，它是一个紧凑的文件，可以传输到远程数据中心或Amazon S3（可能已加密）上。</li>
<li>RDB最大限度地提高了Redis的性能，因为Redis父进程为了持久化所需要做的唯一工作就是分叉一个孩子，其余的都将做。父实例将永远不会执行磁盘I / O或类似操作。</li>
<li>与AOF相比，RDB允许大型数据集更快地重启。</li>
</ul>
<p>RDB的缺点：</p>
<ul>
<li>如果您需要在Redis停止工作（例如断电后）的情况下最大程度地减少数据丢失的机会，则RDB不好。您可以在生成RDB的位置配置不同的保存点（例如，在至少五分钟之后，对数据集进行100次写入，但是您可以有多个保存点）。但是，通常会每隔五分钟或更长时间创建一次RDB快照，因此，如果Redis出于任何原因在没有正确关闭的情况下停止工作，则应该准备丢失最新的数据分钟。</li>
<li>RDB需要经常使用fork（）才能使用子进程将其持久化在磁盘上。如果数据集很大，Fork（）可能很耗时，并且如果数据集很大且CPU性能不佳，则可能导致Redis停止为客户端服务几毫秒甚至一秒钟。AOF还需要fork（），但您可以调整要重写日志的频率，而无需在持久性上进行权衡。</li>
</ul>
<p>AOF的优点：</p>
<ul>
<li>使用AOF Redis更加持久：您可以有不同的fsync策略：完全没有fsync，每秒fsync，每个查询fsync。使用默认策略fsync时，每秒的写入性能仍然很好（fsync是使用后台线程执行的，并且在没有进行fsync的情况下，主线程将尽力执行写入操作。）但是您只能损失一秒钟的写入时间。</li>
<li>AOF日志仅是一个追加日志，因此，如果断电，也不会出现寻道或损坏问题。即使由于某种原因（磁盘已满或其他原因）以半写命令结束日志，redis-check-aof工具也可以轻松修复它。</li>
<li>Redis太大时，Redis可以在后台自动重写AOF。重写是完全安全的，因为Redis继续追加到旧文件时，会生成一个全新的文件，其中包含创建当前数据集所需的最少操作集，一旦准备好第二个文件，Redis会切换这两个文件并开始追加到新的那一个。</li>
<li>AOF以易于理解和解析的格式包含所有操作的日志。您甚至可以轻松导出AOF文件。例如，即使您使用FLUSHALL命令刷新了所有错误文件，如果在此期间未执行任何日志重写操作，您仍然可以保存数据集，只是停止服务器，删除最新命令并重新启动Redis。</li>
</ul>
<p>AOF的缺点：</p>
<ul>
<li>对于相同的数据集，AOF文件通常大于等效的RDB文件。</li>
<li>根据确切的fsync策略，AOF可能比RDB慢。通常，在将fsync设置为每秒的情况下，性能仍然很高，并且在禁用fsync的情况下，即使在高负载下，它也应与RDB一样快。即使在巨大的写负载情况下，RDB仍然能够提供有关最大延迟的更多保证。</li>
<li>过去，我们在特定命令中遇到过罕见的错误（例如，其中一个涉及阻止命令，例如BRPOPLPUSH），导致生成的AOF在重载时无法重现完全相同的数据集。这些错误很少见，我们在测试套件中进行了测试，自动创建了随机的复杂数据集，然后重新加载它们以检查一切是否正常。但是，RDB持久性几乎是不可能的。为了更清楚地说明这一点：Redis AOF通过像MySQL或MongoDB那样增量更新现有状态来工作，而RDB快照一次又一次地创建所有内容，从概念上讲，它更健壮。但是-1）请注意，每次Redis重写AOF时，都会从数据集中包含的实际数据开始重新创建AOF，与始终附加AOF文件（或重写为读取旧AOF而不是读取内存中的数据）相比，提高了对错误的抵抗力。2）我们从未收到过有关真实环境中检测到的AOF损坏的用户报告。<br><a href="http://doc.redisfans.com/topic/persistence.html" target="_blank" rel="noopener">Redis持久化机制</a></li>
</ul>
<p><a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">redis持久化深入</a></p>
<h3 id="Redis缓存过期与淘汰机制是什么？"><a href="#Redis缓存过期与淘汰机制是什么？" class="headerlink" title="Redis缓存过期与淘汰机制是什么？"></a>Redis缓存过期与淘汰机制是什么？</h3><ul>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-enviction（驱逐）：禁止驱逐数据</li>
</ul>
<h2 id="Redis的缓存穿透、缓存击穿是否了解？业界会使⽤什么⽅案？如果缓存⼤规模失效，怎么办？"><a href="#Redis的缓存穿透、缓存击穿是否了解？业界会使⽤什么⽅案？如果缓存⼤规模失效，怎么办？" class="headerlink" title="Redis的缓存穿透、缓存击穿是否了解？业界会使⽤什么⽅案？如果缓存⼤规模失效，怎么办？"></a>Redis的缓存穿透、缓存击穿是否了解？业界会使⽤什么⽅案？如果缓存⼤规模失效，怎么办？</h2><p>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>
<p>解决方案:<br>(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试<br>(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。<br>(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>
<p><a href="https://oss.redislabs.com/redisbloom/#references" target="_blank" rel="noopener">redis bloom</a></p>
<h2 id="使⽤Redis的场景"><a href="#使⽤Redis的场景" class="headerlink" title="使⽤Redis的场景"></a>使⽤Redis的场景</h2><p> 签到，报名，投票： 位图</p>
<pre><code>位图是一个byte数组，可以使用get/set直接设置跟读取整个位图的值，
也可以使用位图操作getbit/setbit等将byte数组当做位数组来处理。
Redis的位数组是自动扩展的，如果设置了阈值且当前超出了阈值会自动将数组进行扩充，
还可以使用bitcount实现快速统计，使用位图查找指令bitpos查找某范围的位图值，
两个指令也可以组合使用对某个范围的位图值进行统计。比如查找一个用户一年中每周末签到数总和。 </code></pre><p>地理位置GEO模块：附近人功能</p>
<h2 id="ZSet底层是如何实现的"><a href="#ZSet底层是如何实现的" class="headerlink" title="ZSet底层是如何实现的"></a>ZSet底层是如何实现的</h2><p><a href="https://www.jianshu.com/p/e5a516831ac2" target="_blank" rel="noopener">ZSet底层是如何实现的</a></p>
<h2 id="HashSet是如何实现的？"><a href="#HashSet是如何实现的？" class="headerlink" title="HashSet是如何实现的？"></a>HashSet是如何实现的？</h2><p>HashSet不能保证元素的顺序，TreeSet中的元素可以按照某个顺序排列。他们的元素都不能重复</p>
<p><a href="https://zhuanlan.zhihu.com/p/80114601" target="_blank" rel="noopener">HashSet是如何实现的</a></p>
<h2 id="redis和zookeeper做分布式锁各有什么优缺点？"><a href="#redis和zookeeper做分布式锁各有什么优缺点？" class="headerlink" title="redis和zookeeper做分布式锁各有什么优缺点？"></a>redis和zookeeper做分布式锁各有什么优缺点？</h2><p>Redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。   </p>
<p>Zookeeper分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。
  </p>
<h2 id="Redis有什么缺点？"><a href="#Redis有什么缺点？" class="headerlink" title="Redis有什么缺点？"></a>Redis有什么缺点？</h2><p>(一)缓存和数据库双写一致性问题<br>(二)缓存雪崩问题<br>(三)缓存击穿问题<br>(四)缓存的并发竞争问题</p>
<p>redis_cluster 不同的key的 set集合数据是在⼀个node还是多个node</p>
<h2 id="为什么说redis能够快速执行"><a href="#为什么说redis能够快速执行" class="headerlink" title="为什么说redis能够快速执行"></a>为什么说redis能够快速执行</h2><pre><code>绝大部分请求是纯粹的内存操作（非常快速）
采用单线程,避免了不必要的上下文切换和竞争条件
非阻塞IO - IO多路复用</code></pre><h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ul>
<li>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li>
<li>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li>
<li>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li>
<li>(4) 尽量避免在压力很大的主库上增加从库 </li>
<li>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</li>
</ul>
<h2 id="为什么Redis不支持回滚"><a href="#为什么Redis不支持回滚" class="headerlink" title="为什么Redis不支持回滚"></a>为什么Redis不支持回滚</h2><p>Redis命令在事务期间可能会失败，但Redis仍将执行事务的其余部分而不是回滚</p>
<ul>
<li><p>仅当使用错误的语法（并且在命令队列期间无法检测到该问题）或针对持有错误数据类型的键调用Redis命令时，该命令才能失败：这实际上意味着失败的命令是编程错误的结果，还有一种很可能在开发过程中而不是生产过程中发现的错误。</p>
</li>
<li><p>Redis在内部得到了简化和更快，因为它不需要回滚的能力。</p>
</li>
<li><p><a href="https://redis.io/topics/transactions#why-redis-does-not-support-roll-backs" target="_blank" rel="noopener">为什么Redis不支持回滚</a></p>
<h2 id="Redis使用epoll异步非阻塞模型-，Redis自身实现了事件处理模型将epoll中的链接、读写、关闭都转换为事件，不在网络IO上浪费过多的事"><a href="#Redis使用epoll异步非阻塞模型-，Redis自身实现了事件处理模型将epoll中的链接、读写、关闭都转换为事件，不在网络IO上浪费过多的事" class="headerlink" title="Redis使用epoll异步非阻塞模型 ，Redis自身实现了事件处理模型将epoll中的链接、读写、关闭都转换为事件，不在网络IO上浪费过多的事"></a>Redis使用epoll异步非阻塞模型 ，Redis自身实现了事件处理模型将epoll中的链接、读写、关闭都转换为事件，不在网络IO上浪费过多的事</h2><p><a href="https://www.cnblogs.com/allenwas3/p/8473614.html" target="_blank" rel="noopener">redis使用epoll</a></p>
<h2 id="升级redis集群节点"><a href="#升级redis集群节点" class="headerlink" title="升级redis集群节点"></a>升级redis集群节点</h2><p>升级从节点：</p>
<p>  停止节点并使用更新版本的Redis重新启动它即可。<br>  如果存在使用从属节点扩展读取的客户端，则在给定的从属节点不可用时，<br>  它们应该能够重新连接到其他从属节点</p>
</li>
</ul>
<p>升级master节点：</p>
<ul>
<li>使用CLUSTER FAILOVER触发主服务器到其从服务器之一的手动故障转移。</li>
<li>等待主机变成从机。</li>
<li>最后，像对从属服务器一样升级节点。</li>
<li>如果要将主节点作为刚刚升级的节点，请触发新的手动故障转移，以将升级后的节点转换回主节点。</li>
</ul>
<p><a href="https://redis.io/topics/cluster-tutorial/#upgrading-nodes-in-a-redis-cluster" target="_blank" rel="noopener">升级redis集群节点</a></p>
<p>##<br>参考资料：</p>
<p><a href="https://blog.csdn.net/qq_42322103/article/details/104159919/" target="_blank" rel="noopener">redis常用命令解析</a></p>
<p><a href="https://redis.io/commands" target="_blank" rel="noopener">redis_commands_list</a></p>
<p><a href="https://redis.io/topics/faq" target="_blank" rel="noopener">redis-FAQ</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-redis" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/17/redis/" class="article-date">
  	<time datetime="2020-03-17T13:43:58.657Z" itemprop="datePublished">2020-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#1、持久化</p>
<p>RDB 快照</p>
<p>恢复快，数据存储量大，数据丢失多</p>
<p>AOF 日志</p>
<p>恢复慢，数据存储量小，数据丢失少，</p>
<p>文件存储在 <code>/var/lib/redis/6379</code> </p>
<p>日志文件越来越大的时候，而key值不断被修改，可以通过手动 <code>BGREWRITEAOF</code>重置日志文件。<br>可以抵消重复的数据。</p>
<p>R&amp;A</p>
<p>配置文件开启<br>    <code>vi/etc/redis/6379.conf</code></p>
<pre><code>`aof-use-rdb-preamble yes`</code></pre><h1 id="2、主从复制集群"><a href="#2、主从复制集群" class="headerlink" title="2、主从复制集群"></a>2、主从复制集群</h1><p>AFK微服务划分原则</p>
<p>CAP定理</p>
<h1 id="3、redis、zookeeper分布式锁对比"><a href="#3、redis、zookeeper分布式锁对比" class="headerlink" title="3、redis、zookeeper分布式锁对比"></a>3、redis、zookeeper分布式锁对比</h1><p><a href="https://zhuanlan.zhihu.com/p/93947224" target="_blank" rel="noopener">如何正确使用redis分布式锁</a></p>
<p><a href="https://www.w3cschool.cn/redis/redis-yj3f2p0c.html" target="_blank" rel="noopener">Redis分布式锁正确的实现方法</a></p>
<p>假如Redis节点宕机了，那么所有客户端就都无法获得锁了，服务变得不可用。<br>为了提高可用性，我们可以给这个Redis节点挂一个Slave，当Master节点不可用的时候，<br>系统自动切到Slave上（failover）。但由于Redis的主从复制（replication）是异步的，<br>这可能导致在failover过程中丧失锁的安全性。<br>针对这个问题，可以参考一下<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Redlock</a>的算法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-偏向锁-自旋锁-重量级锁" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/17/偏向锁-自旋锁-重量级锁/" class="article-date">
  	<time datetime="2020-03-17T13:08:32.728Z" itemprop="datePublished">2020-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#1、偏向锁</p>
<h1 id="2、自旋锁"><a href="#2、自旋锁" class="headerlink" title="2、自旋锁"></a>2、自旋锁</h1><h1 id="3、重量级锁"><a href="#3、重量级锁" class="headerlink" title="3、重量级锁"></a>3、重量级锁</h1><p>自旋锁是要占用CPU的，线程数量过多的时候，用自旋锁不合适</p>
<p>当自旋超过10，或者当前线程超过CPU的二分之一，升级为重量级锁。</p>
<p>Adaptive CAS: 自适应自旋。自动判断是否升级为重量级锁</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-mysql/mysql事务" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/15/mysql/mysql事务/" class="article-date">
  	<time datetime="2020-03-15T13:44:03.166Z" itemprop="datePublished">2020-03-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、原子性实现原理：Undo-log"><a href="#1、原子性实现原理：Undo-log" class="headerlink" title="1、原子性实现原理：Undo log"></a>1、原子性实现原理：Undo log</h1><pre><code>- Undo log是为了实现事务的原子性，在mysql数据库InnoDB存储引擎中，
还用Undo log来实现多版本并发控制（MVCC）
- 在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo log）.
然后进行数据修改。如果出现了错误或者用户执行了ROLLBACK语句，
系统可以利用undo log中的备份将数据恢复到事务之前的状态
- 注意：undo log是逻辑日志，可以理解为：
    - 当delete一条记录时，undo log中会记录一条对应的insert记录
    - 当insert一条记录时，undo log中会记录一条对应的delete记录
    - 当update一条记录时，undo log中会记录一条相反的update记录


（逻辑日志的意思是记录某一行数据的修改，物理日志是记录某一页的数据修改）</code></pre><h1 id="2、持久性原理：-Redo-log"><a href="#2、持久性原理：-Redo-log" class="headerlink" title="2、持久性原理： Redo log"></a>2、持久性原理： Redo log</h1><pre><code>- 和undo log相反，redo log记录的是新数据的备份。(异步写)
在事务提交前，只要将redo log持久化即可，不需要将数据持久化。
当系统崩溃时，虽然数据没有持久化，但是redo log已经持久化。
系统可以根据 redo log 的内容，将所有数据恢复到最新的状态
（innodb_flush_log_at_trx_commit）
WAL(write ahead log):预写日志</code></pre><p>当我们每次执行update,insert,delete等语句后，commit操作后，redo log执行持久化操作</p>
<p>innodb_flush_log_at_trx_commit = 0/1/2</p>
<pre><code>set global innodb_flush_log_at_trx_commit=2;
show variables like &apos;innodb_flush_log_at_trx_commit&apos;;</code></pre><p>默认值为：1</p>
<p>由于实时将数据刷到磁盘中，在并发条件下，性能较低，<br><img src="../mysql%E4%BA%8B%E5%8A%A1/1.png" alt></p>
<h1 id="3、mysql的隔离级别"><a href="#3、mysql的隔离级别" class="headerlink" title="3、mysql的隔离级别"></a>3、mysql的隔离级别</h1><ul>
<li>读未提交(read_uncommitted):对事务处理的读取没有任何限制；</li>
<li>读已提交(read_committed)：</li>
<li>可重复读(repeatable_read):默认级别</li>
<li>串行化(seriauzable)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">事务的隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交(read_uncommitted)</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">读已提交(read_committed)</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">可重复读(repeatable_read)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">串行化(seriauzable)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h1><p>事务的并发执行，事务故障或系统故障  会对事务的一致性造成破坏</p>
<p>数据库系统通过并发控制技术和日志恢复技术来避免这种情况的发生：<br>    - 并发控制技术保证了事务的隔离性（加锁），使数据库的一致性状态不会<br>    因为并发执行的操作被破坏。<br>    - 日志恢复技术保证了事务的原子性，是一致性状态下不会因事务或系统故障被破坏。<br>    同时使已提交的对数据库的修改不会因为系统崩溃而丢失，保证了事务的持久性。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-mysql/mysql连接器-分析器-优化器-执行器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/15/mysql/mysql连接器-分析器-优化器-执行器/" class="article-date">
  	<time datetime="2020-03-15T12:17:16.472Z" itemprop="datePublished">2020-03-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>mysqlServer分为：连接器，分析器，优化器，执行器。</p>
<h1 id="1、连接器"><a href="#1、连接器" class="headerlink" title="1、连接器"></a>1、连接器</h1><pre><code>管理用户的连接
show processlist;</code></pre><h1 id="2、分析器"><a href="#2、分析器" class="headerlink" title="2、分析器"></a>2、分析器</h1><pre><code>词法分析，语法分析</code></pre><p>calcite 开源数据库分析组件。</p>
<h1 id="3、优化器"><a href="#3、优化器" class="headerlink" title="3、优化器"></a>3、优化器</h1><pre><code>优化sql语句，规定执行流程</code></pre><h1 id="4、执行器"><a href="#4、执行器" class="headerlink" title="4、执行器"></a>4、执行器</h1><pre><code>sql语句实际执行组件</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2020 zhangyong
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>