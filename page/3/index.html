<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>zhangyong</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="zhangyong">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="zhangyong">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhangyong">
  
    <link rel="alternative" href="/atom.xml" title="zhangyong" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head></html>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars0.githubusercontent.com/u/39975746?s=400&amp;u=5c82d9ef34c547270f3fbe1d343a296e3ebdce25&amp;v=4" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">zhangyong</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">zhangyong</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars0.githubusercontent.com/u/39975746?s=400&amp;u=5c82d9ef34c547270f3fbe1d343a296e3ebdce25&amp;v=4" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">zhangyong</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-kafka" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/29/kafka/" class="article-date">
  	<time datetime="2020-02-29T04:18:45.165Z" itemprop="datePublished">2020-02-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#1、安装kafka</p>
<p><a href="http://kafka.apache.org/quickstart" target="_blank" rel="noopener">kafka-quickstart</a></p>
<p>#2 分区存储文件原理</p>
<p>#3 kafka选择分区模式</p>
<p>#4 生产者往kafka发送数据的模式</p>
<p>#5 为什么kafka快</p>
<p>#6 消费者组消费数据的原理</p>
<p>#7 生产者往kafka发送数据原理</p>
<h2 id="kafka和rocketmq都能实现消息队列，为什么要引入rocket，不直接使用kafka"><a href="#kafka和rocketmq都能实现消息队列，为什么要引入rocket，不直接使用kafka" class="headerlink" title="kafka和rocketmq都能实现消息队列，为什么要引入rocket，不直接使用kafka"></a>kafka和rocketmq都能实现消息队列，为什么要引入rocket，不直接使用kafka</h2><h2 id="zk-分布式锁慢-除了IO慢之外还有其他原因吗？"><a href="#zk-分布式锁慢-除了IO慢之外还有其他原因吗？" class="headerlink" title="zk 分布式锁慢 除了IO慢之外还有其他原因吗？"></a>zk 分布式锁慢 除了IO慢之外还有其他原因吗？</h2><p>排它锁的粒度大，没有区分读、写操作，如果读多写少，则十分影响性能<br>羊群效应：锁释放后会通知所有等待中的 ZooKeeper 客户端，然后同时发起加锁请求，瞬时压力很大</p>
<p>解决方案是：</p>
<p>1.缩小通知范围：等待锁的小伙伴们按先来后到的顺序排队吧，排好队了，接下来我只需要关心我前面一个节点的状态，当前一个节点被释放，我再去抢锁。</p>
<p>2.缩小锁的粒度：锁不关心业务，但是可以简单地通过操作的读、写性质来二分锁的粒度：<br>读锁：又称共享锁，如果前面没有写节点，可以直接上锁；当前面有写节点时，则等待距离自己最近的写节点释放（ 删除 ）。<br>写锁：如果前面没有节点，可以直接上锁；如果前面有节点，则等待前一个节点释放（ 删除 ）。  </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/golang包管理工具" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/29/golang/golang包管理工具/" class="article-date">
  	<time datetime="2020-02-29T02:46:57.979Z" itemprop="datePublished">2020-02-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="go-dep"><a href="#go-dep" class="headerlink" title="go dep"></a>go dep</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>执行以下命令安装<code>godep</code>工具。</p>
<pre><code>go get github.com/tools/godep</code></pre><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>安装好<code>godep</code>之后，在终端输入<code>godep</code>查看支持的所有命令。</p>
<pre><code>godep save     将依赖项输出并复制到Godeps.json文件中
godep go       使用保存的依赖项运行go工具
godep get      下载并安装具有指定依赖项的包
godep path     打印依赖的GOPATH路径
godep restore  在GOPATH中拉取依赖的版本
godep update   更新选定的包或go版本
godep diff     显示当前和以前保存的依赖项集之间的差异
godep version  查看版本信息</code></pre><p>使用<code>godep help [command]</code>可以看看具体命令的帮助信息。</p>
<p>使用godep<br>在项目目录下执行godep save命令，会在当前项目中创建Godeps和vender两个文件夹。</p>
<p>其中Godeps文件夹下有一个Godeps.json的文件，里面记录了项目所依赖的包信息。 vender文件夹下是项目依赖的包的源代码文件。</p>
<h3 id="go-dep开发流程"><a href="#go-dep开发流程" class="headerlink" title="go dep开发流程"></a>go dep开发流程</h3><p>保证程序能够正常编译</p>
<p>执行<code>godep save</code>保存当前项目的所有第三方依赖的版本信息和代码</p>
<p>提交<code>Godeps</code>目录和<code>vender</code>目录到代码库。</p>
<p>如果要更新依赖的版本，可以直接修改<code>Godeps.json</code>文件中的对应项</p>
<h3 id="vender机制"><a href="#vender机制" class="headerlink" title="vender机制"></a>vender机制</h3><p>Go1.5版本之后开始支持，能够控制Go语言程序编译时依赖包搜索路径的优先级。</p>
<p>例如查找项目的某个依赖包，首先会在项目根目录下的<code>vender</code>文件夹中查找，如果没有找到就会去<code>$GOAPTH/src</code>目录下查找。</p>
<p>##go module<br>go module是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。</p>
<h3 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h3><p>常用的go mod命令如下：</p>
<pre><code>go mod download    下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录）
go mod edit        编辑go.mod文件
go mod graph       打印模块依赖图
go mod init        初始化当前文件夹, 创建go.mod文件
go mod tidy        增加缺少的module，删除无用的module
go mod vendor      将依赖复制到vendor下
go mod verify      校验依赖
go mod why         解释为什么需要依赖

module用来定义包名
require用来定义依赖包及版本
indirect表示间接引用</code></pre><h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>GOPROXY 的默认值是：</p>
<pre><code>https://proxy.golang.org,direct</code></pre><p>这有一个很严重的问题，就是 <code>proxy.golang.org</code> 在国内是无法访问的，<br>因此这会直接卡住你的第一步，所以你必须在开启 Go modules 的时<br>，同时设置国内的 Go 模块代理，执行如下命令：</p>
<pre><code>$ go env -w GOPROXY=https://goproxy.cn,direct</code></pre><h3 id="命令行开启-Go-Modules"><a href="#命令行开启-Go-Modules" class="headerlink" title="命令行开启 Go Modules"></a>命令行开启 Go Modules</h3><p>目前 Go modules 并不是默认开启，因此Go语言提供了 GO111MODULE 这个环境变量来作为 Go modules 的开关，其允许设置以下参数：</p>
<ul>
<li>auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在Go1.11至 Go1.14 中仍然是默认值。</li>
<li>on：启用 Go modules，推荐设置，将会是未来版本中的默认值。</li>
<li>off：禁用 Go modules，不推荐设置。</li>
</ul>
<p>如果你不确定你当前的值是什么，可以执行go env命令，查看结果：</p>
<pre><code>$ go env
GO111MODULE=&quot;off&quot;</code></pre><p>如果需要对 GO111MODULE 的值进行变更，推荐通过go env命令进行设置：</p>
<pre><code>$ go env -w GO111MODULE=on</code></pre><h3 id="goland中启用go-module"><a href="#goland中启用go-module" class="headerlink" title="goland中启用go module"></a>goland中启用go module</h3><p><img src="../golang%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/%E5%BC%80%E5%90%AFgomodule.png" alt></p>
<p>代理可以设置为：<code>https://goproxy.cn</code></p>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><pre><code>go mod init</code></pre><h3 id="go-mod-文件"><a href="#go-mod-文件" class="headerlink" title="go.mod 文件"></a>go.mod 文件</h3><p>在初始化项目时，会生成一个 go.mod 文件，是启用了 Go modules 项目所必须的最重要的标识.</p>
<p>示例：</p>
<pre><code>module github.com/example
go 1.13

require (
    github.com/jinzhu/gorm v1.9.12 // indirect
)
exclude github.com/jinzhu/gorm v1.9.11
replace github.com/go-kit/kit v0.9.0 =&gt; github.com/go-kit/kit v0.8.0</code></pre><ul>
<li>module：用于定义当前项目的模块路径。</li>
<li>go：用于标识当前模块的 Go 语言版本，值为初始化模块时的版本，<code>升级golang版本时，要注意是否需要更改此处</code></li>
<li>require：用于设置一个特定的模块版本。</li>
<li>exclude：用于从使用中排除一个特定的模块版本。</li>
<li>replace：用于将一个模块版本替换为另外一个模块版本  </li>
</ul>
<h3 id="go-sum-文件"><a href="#go-sum-文件" class="headerlink" title="go.sum 文件"></a>go.sum 文件</h3><p>go.sum 文件详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p>
<pre><code>cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
github.com/BurntSushi/toml v0.3.1 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
....</code></pre><p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。</p>
<p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。</p>
<h2 id="替代包"><a href="#替代包" class="headerlink" title="替代包"></a>替代包</h2><p>在管理过程中，导入的包为 <code>0.9.0</code> 版本，实际需要<code>0.8.0</code>版本，需要将导入的<code>0.9.0</code>版本<br>用<code>replace</code>替代为 <code>0.8.0</code> 版本</p>
<pre><code>go 1.13

require (
    github.com/jinzhu/gorm v1.9.12 // indirect
)
replace github.com/go-kit/kit v0.9.0 =&gt; github.com/go-kit/kit v0.8.0</code></pre><p>也可以用命令行模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace=old[@v]=new[@v]</span><br></pre></td></tr></table></figure>

<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://mp.weixin.qq.com/s/nd8ic1Qk812ZqmHKSFITUQ" target="_blank" rel="noopener">学习 Go Modules 这一篇就够：终极入门</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/利用goland搭建gin框架" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/29/golang/利用goland搭建gin框架/" class="article-date">
  	<time datetime="2020-02-29T02:38:22.273Z" itemprop="datePublished">2020-02-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##1 go gin</p>
<p>##2 安装</p>
<p><a href="https://gin-gonic.com/zh-cn/docs/" target="_blank" rel="noopener">gin-gonic</a></p>
<p><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">gin</a></p>
<pre><code>go get -u github.com/gin-gonic/gin</code></pre><p>##3 导入<br>    package main</p>
<pre><code>import &quot;github.com/gin-gonic/gin&quot;

func main() {
    r := gin.Default()
    r.GET(&quot;/ping&quot;, func(c *gin.Context) {
        c.JSON(200, gin.H{
            &quot;message&quot;: &quot;pong&quot;,
        })
    })
    r.Run() // listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)
}</code></pre><p>##4 API Examples</p>
<p>Using GET, POST, PUT, PATCH, DELETE and OPTIONS</p>
<pre><code>func main() {
    // Creates a gin router with default middleware:
    // logger and recovery (crash-free) middleware
    router := gin.Default()

    router.GET(&quot;/someGet&quot;, getting)
    router.POST(&quot;/somePost&quot;, posting)
    router.PUT(&quot;/somePut&quot;, putting)
    router.DELETE(&quot;/someDelete&quot;, deleting)
    router.PATCH(&quot;/somePatch&quot;, patching)
    router.HEAD(&quot;/someHead&quot;, head)
    router.OPTIONS(&quot;/someOptions&quot;, options)

    // By default it serves on :8080 unless a
    // PORT environment variable was defined.
    router.Run()
    // router.Run(&quot;:3000&quot;) for a hard coded port
}</code></pre><p>Parameters in path</p>
<pre><code>func main() {
    router := gin.Default()

    // This handler will match /user/john but will not match /user/ or /user
    router.GET(&quot;/user/:name&quot;, func(c *gin.Context) {
        name := c.Param(&quot;name&quot;)
        c.String(http.StatusOK, &quot;Hello %s&quot;, name)
    })

    // However, this one will match /user/john/ and also /user/john/send
    // If no other routers match /user/john, it will redirect to /user/john/
    router.GET(&quot;/user/:name/*action&quot;, func(c *gin.Context) {
        name := c.Param(&quot;name&quot;)
        action := c.Param(&quot;action&quot;)
        message := name + &quot; is &quot; + action
        c.String(http.StatusOK, message)
    })

    // For each matched request Context will hold the route definition
    router.POST(&quot;/user/:name/*action&quot;, func(c *gin.Context) {
        c.FullPath() == &quot;/user/:name/*action&quot; // true
    })

    router.Run(&quot;:8080&quot;)
}</code></pre><p>Querystring parameters</p>
<pre><code>func main() {
    router := gin.Default()

    // Query string parameters are parsed using the existing underlying request object.
    // The request responds to a url matching:  /welcome?firstname=Jane&amp;lastname=Doe
    router.GET(&quot;/welcome&quot;, func(c *gin.Context) {
        firstname := c.DefaultQuery(&quot;firstname&quot;, &quot;Guest&quot;)
        lastname := c.Query(&quot;lastname&quot;) // shortcut for c.Request.URL.Query().Get(&quot;lastname&quot;)

        c.String(http.StatusOK, &quot;Hello %s %s&quot;, firstname, lastname)
    })
    router.Run(&quot;:8080&quot;)
}</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/go_上台阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/16/golang/go_上台阶/" class="article-date">
  	<time datetime="2020-02-16T13:55:33.706Z" itemprop="datePublished">2020-02-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#1、上台阶</p>
<p>递归问题</p>
<p><code>https://blog.csdn.net/qq_27068845/article/details/90181340</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/go_slice" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/16/golang/go_slice/" class="article-date">
  	<time datetime="2020-02-16T02:56:37.819Z" itemprop="datePublished">2020-02-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p><a href="https://www.cnblogs.com/aaronthon/p/10673841.html" target="_blank" rel="noopener">https://www.cnblogs.com/aaronthon/p/10673841.html</a></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1、声明数组"><a href="#1、声明数组" class="headerlink" title="1、声明数组"></a>1、声明数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一、</span><br><span class="line">    var names [3]int</span><br><span class="line">	names = [3]int&#123;1, 2, 3&#125;</span><br><span class="line">	</span><br><span class="line">二、</span><br><span class="line">    var names =  [...]int&#123;1, 2, 3&#125;</span><br><span class="line">   </span><br><span class="line">三、</span><br><span class="line">    var names = [...]int&#123;0:1, 1:2, 2:3&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-数组是值类型"><a href="#2-数组是值类型" class="headerlink" title="2 数组是值类型"></a>2 数组是值类型</h3><h2 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、</span><br><span class="line">    var s1 []int</span><br><span class="line">    s1 = []int&#123;1, 2, 3&#125;</span><br><span class="line">2、</span><br><span class="line">    var s1 = make&#123;[]int, 10, 10&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h2><p><img src="../go_slice/slice.png" alt></p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>可以通过查看$GOROOT/src/runtime/slice.go源码，其中扩容相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.cap</span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	if cap &gt; doublecap &#123;</span><br><span class="line">		newcap = cap</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if old.len &lt; 1024 &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// Check 0 &lt; newcap to detect overflow</span><br><span class="line">			// and prevent an infinite loop.</span><br><span class="line">			for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123;</span><br><span class="line">				newcap += newcap / 4</span><br><span class="line">			&#125;</span><br><span class="line">			// Set newcap to the requested cap when</span><br><span class="line">			// the newcap calculation overflowed.</span><br><span class="line">			if newcap &lt;= 0 &#123;</span><br><span class="line">				newcap = cap</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出以下内容：</p>
<p>· 首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</p>
<p>· 否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</p>
<p>· 否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</p>
<p>· 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</p>
<p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。</p>
<h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>· srcSlice: 数据来源切片</p>
<p>· destSlice: 目标切片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // copy()复制切片</span><br><span class="line">    a := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">    c := make([]int, 5, 5)</span><br><span class="line">    copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c</span><br><span class="line">    fmt.Println(a) //[1 2 3 4 5]</span><br><span class="line">    fmt.Println(c) //[1 2 3 4 5]</span><br><span class="line">    c[0] = 1000</span><br><span class="line">    fmt.Println(a) //[1 2 3 4 5]</span><br><span class="line">    fmt.Println(c) //[1000 2 3 4 5]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   var a3 = [...]int&#123;3, 7, 8, 9, 1&#125;</span><br><span class="line">s3 := a3[:]</span><br><span class="line">fmt.Println(&quot;a3: &quot;, a3)</span><br><span class="line">fmt.Println(s3, len(s3), cap(s3))</span><br><span class="line">   //删除index为1的元素</span><br><span class="line">s3 = append(s3[:1], s3[2:]...)</span><br><span class="line">fmt.Println(&quot;a3: &quot;, a3)</span><br><span class="line">fmt.Println(s3, len(s3), cap(s3))</span><br></pre></td></tr></table></figure>

<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var a = make([]string, 5, 10)</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        a = append(a, fmt.Sprintf(&quot;%v&quot;, i))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[     0 1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure>

<p>2.请使用内置的sort包对数组var a = […]int{3, 7, 8, 9, 1}进行排序。</p>
<p><a href="https://blog.csdn.net/qq_39920531/article/details/88059636" target="_blank" rel="noopener">https://blog.csdn.net/qq_39920531/article/details/88059636</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Ints(a[:])</span><br></pre></td></tr></table></figure>

<p>3 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a3 = [...]int&#123;3, 7, 8, 9, 1&#125;</span><br><span class="line">s3 := a3[:]</span><br><span class="line">fmt.Println(&quot;a3: &quot;, a3)</span><br><span class="line">fmt.Println(s3, len(s3), cap(s3))</span><br><span class="line"></span><br><span class="line">s3 = append(s3[:1], s3[2:]...)</span><br><span class="line">fmt.Println(&quot;a3: &quot;, a3)</span><br><span class="line">fmt.Println(s3, len(s3), cap(s3))</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a3:  [3 7 8 9 1]</span><br><span class="line">[3 7 8 9 1] 5 5</span><br><span class="line">a3:  [3 8 9 1 1]</span><br><span class="line">[3 8 9 1] 4 5</span><br></pre></td></tr></table></figure>

<p>4、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s1 []int</span><br><span class="line">s1[1] = 100</span><br><span class="line">fmt.Println(s1)  // error</span><br><span class="line"></span><br><span class="line">var s1 []int</span><br><span class="line">s1 = append(s1, 1)</span><br><span class="line">fmt.Println(s1)   // [1]</span><br></pre></td></tr></table></figure>

<p>5、判断是否为回文，”山西运煤车煤运西山”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var ss = &quot;山西运煤车煤运西山&quot;</span><br><span class="line">	var r1 = make([]rune, 0, len(ss))</span><br><span class="line">	for _, r := range ss &#123;</span><br><span class="line">		r1 = append(r1, r)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for i:=0; i&lt;len(r1)/2; i++ &#123;</span><br><span class="line">		if r1[i] != r1[len(r1)-1-i] &#123;</span><br><span class="line">			fmt.Println(&quot;不是回文&quot;)</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;是回文&quot;)</span><br></pre></td></tr></table></figure>

<p>##参考资料：</p>
<p><a href="https://mp.weixin.qq.com/s/Hl6qExD0PSA29ZoaD4WitA" target="_blank" rel="noopener">Slice实现原理分析</a></p>
<p>简单来说，makeslice函数的工作主要就是计算slice所需内存大小，然后调用mallocgc进行内存的分配。计算slice所需内存又是通过MulUintptr来实现的，MulUintptr的源码我们也已经贴出，主要就是用切片中元素大小和切片的容量相乘计算出所需占用的内存空间，如果内存溢出，或者计算出的内存大小大于最大可分配内存，MulUintptr的overflow会返回true，makeslice就会报错。另外如果传入长度小于0或者长度小于容量，makeslice也会报错。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/go数据类型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/16/golang/go数据类型/" class="article-date">
  	<time datetime="2020-02-16T02:45:39.489Z" itemprop="datePublished">2020-02-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.cnblogs.com/itbsl/p/9854681.html" target="_blank" rel="noopener">https://www.cnblogs.com/itbsl/p/9854681.html</a></p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>无符号整型：<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code></p>
<p>带符号整型：<code>int8</code> <code>int16</code> <code>int32</code> <code>int64</code></p>
<p><code>uint</code>和<code>int</code>具体是32位还是64位看操作系统</p>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>float32和float64 </p>
<p>Go语言中浮点数默认是float64</p>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex128和complex64</p>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>boolean</p>
<p>##字符串<br>string</p>
<h2 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h2><p>go语言中字符串都是UTF-8编码，UTF-8编码中一个常用汉字一般占3个字符</p>
<p>由于rune可表示的范围更大，所以能处理一切字符，当然也包括中文字符。在平时计算中文字符，可用rune。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var chinese = &quot;我是中国人， I am Chinese&quot;</span><br><span class="line">    fmt.Println(&quot;chinese length&quot;, len(chinese))</span><br><span class="line">    fmt.Println(&quot;chinese word length&quot;, len([]rune(chinese)))</span><br><span class="line">    fmt.Println(&quot;chinese word length&quot;, utf8.RuneCountInString(chinese))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出，注意在golang中一个汉字占3个byte</span><br><span class="line">chinese length 31</span><br><span class="line">chinese word length 19</span><br><span class="line">chinese word length 19</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/go_指针" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/16/golang/go_指针/" class="article-date">
  	<time datetime="2020-02-16T02:16:20.241Z" itemprop="datePublished">2020-02-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   var a int= 20   /* 声明实际变量 */</span><br><span class="line">   var ip *int        /* 声明指针变量 */</span><br><span class="line"></span><br><span class="line">   ip = &amp;a  /* 指针变量的存储地址 */</span><br><span class="line"></span><br><span class="line">   fmt.Printf(&quot;a 变量的地址是: %x\n&quot;, &amp;a  )</span><br><span class="line"></span><br><span class="line">   /* 指针变量的存储地址 */</span><br><span class="line">   fmt.Printf(&quot;ip 变量储存的指针地址: %x\n&quot;, ip )</span><br><span class="line"></span><br><span class="line">   /* 使用指针访问值 */</span><br><span class="line">   fmt.Printf(&quot;*ip 变量的值: %d\n&quot;, *ip )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p>
<p>nil 指针也称为空指针。</p>
<p>nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    var a *int</span><br><span class="line">*a = 100</span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line">运行时异常：</span><br><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line"></span><br><span class="line">var a = new(int)</span><br><span class="line">fmt.Println(a)     //&lt;nil&gt;</span><br><span class="line">fmt.Println(*a)    // 0</span><br><span class="line">*a = 100  </span><br><span class="line">fmt.Println(*a)    //100</span><br></pre></td></tr></table></figure>

<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>###make和new区别</p>
<p>1、都是用来申请内存的。</p>
<p>2、 make只适用于 slice，map和 channle的内存创建，而且他返回的类型就是他们三个类型本身，而不是他们的指针类型，因为他们是引用类型，所以就没有必要返回他们的指针了。</p>
<p>3、 new很少用，一般用来给基本数据类型申请内存， <code>string</code>，<code>int</code>；返回的都是对应的类型的指针(*string, *int)</p>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var m1  map[string]int</span><br><span class="line">	m1 = make(map[string]int, 10)</span><br><span class="line">	m1[&quot;m1&quot;] = 1</span><br><span class="line">	m1[&quot;m2&quot;] = 2</span><br><span class="line"></span><br><span class="line">	fmt.Println(m1)</span><br><span class="line">//若key不存在，则返回0</span><br><span class="line">	fmt.Println(m1[&quot;m3&quot;])  // 0</span><br><span class="line">	</span><br><span class="line">	for k := range m1&#123;</span><br><span class="line">    		fmt.Println(k)</span><br><span class="line">    	&#125;</span><br><span class="line">    	for k, v := range m1&#123;</span><br><span class="line">    		fmt.Println(k, v)</span><br><span class="line">    	&#125;</span><br><span class="line">    	for _, v := range m1&#123;</span><br><span class="line">    		fmt.Println(v)</span><br><span class="line">    	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map-排序"><a href="#map-排序" class="headerlink" title="map 排序"></a>map 排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">var sortMap = make(map[string]int, 100)</span><br><span class="line">var keys = make([]string, 0, 200)</span><br><span class="line">for i := 1; i&lt;100; i++  &#123;</span><br><span class="line">	key := fmt.Sprintf(&quot;student_%02d&quot;, i)</span><br><span class="line">	value := rand.Intn(100)</span><br><span class="line">	sortMap[key] = value</span><br><span class="line">	keys = append(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"></span><br><span class="line">for _, k := range keys &#123;</span><br><span class="line">	fmt.Println(k, sortMap[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###值为map的切片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var s1 = make([]map[string]int, 10, 10)</span><br><span class="line">s1[0] = make(map[string]int, 10)</span><br><span class="line">s1[0][&quot;北京&quot;] = 100</span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">//[map[北京:100] map[] map[] map[] map[] map[] map[] map[] map[] map[]]</span><br></pre></td></tr></table></figure>

<h3 id="值为切片的map"><a href="#值为切片的map" class="headerlink" title="值为切片的map"></a>值为切片的map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var m1 = make(map[string][]int, 10)</span><br><span class="line">m1[&quot;北京&quot;] = make([]int, 10, 10)</span><br><span class="line">m1[&quot;北京&quot;][0] = 1</span><br><span class="line">fmt.Println(m1)</span><br><span class="line"></span><br><span class="line">//map[北京:[1 0 0 0 0 0 0 0 0 0]]</span><br></pre></td></tr></table></figure>

<h2 id="统计一个字符串中每个单词出现的次数，比如”how-do-you-do-“-中-how-1次，do-2次，you-1次"><a href="#统计一个字符串中每个单词出现的次数，比如”how-do-you-do-“-中-how-1次，do-2次，you-1次" class="headerlink" title="统计一个字符串中每个单词出现的次数，比如”how do you do “ 中  how 1次，do 2次，you 1次"></a>统计一个字符串中每个单词出现的次数，比如”how do you do “ 中  how 1次，do 2次，you 1次</h2><pre><code>var map1 = make(map[string]int, 10)
var str1 = &quot;how do you do how do you do how do you do&quot;
var s1 = make([]string, 10, 10)
s1 = strings.Split(str1, &quot; &quot;)
fmt.Println(s1)
for _, item := range s1 {
    value, ok := map1[item]
    fmt.Println(item)
    if ok{
        value ++
        map1[item] = value
    }else {
        map1[item] = 1
    }
}
fmt.Println(map1)</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-golang/go跨平台编译" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/11/golang/go跨平台编译/" class="article-date">
  	<time datetime="2020-02-11T11:15:39.719Z" itemprop="datePublished">2020-02-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#1、跨平台编译<br><a href="https://studygolang.com/articles/20471" target="_blank" rel="noopener">https://studygolang.com/articles/20471</a></p>
<h2 id="windows平台下编译linux可执行文件："><a href="#windows平台下编译linux可执行文件：" class="headerlink" title="windows平台下编译linux可执行文件："></a>windows平台下编译linux可执行文件：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0 //禁用CGO</span><br><span class="line">SET GOOS=linux //目标平台是linux</span><br><span class="line">SET GOARCH=amd64 // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure>

<p>再执行 ‘go bulid’ 命令，就可以得到在linux平台运行的可执行文件了</p>
<h2 id="Mac-下编译-Linux-和windows平台64位可执行文件"><a href="#Mac-下编译-Linux-和windows平台64位可执行文件" class="headerlink" title="Mac 下编译 Linux 和windows平台64位可执行文件"></a>Mac 下编译 Linux 和windows平台64位可执行文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 </span><br><span class="line">GOOS=darwin </span><br><span class="line">GOARCH=amd64</span><br><span class="line">go bulid</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 </span><br><span class="line">GOOS=windows </span><br><span class="line">GOARCH=amd64</span><br><span class="line">go bulid</span><br></pre></td></tr></table></figure>

<h2 id="windows下编译Mac平台64位可执行文件"><a href="#windows下编译Mac平台64位可执行文件" class="headerlink" title="windows下编译Mac平台64位可执行文件"></a>windows下编译Mac平台64位可执行文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 </span><br><span class="line">GOOS=darwin </span><br><span class="line">GOARCH=amd64</span><br><span class="line">go bulid</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-联盟链-Fabric比较其他联盟链的优势" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/10/联盟链-Fabric比较其他联盟链的优势/" class="article-date">
  	<time datetime="2020-02-10T02:40:34.939Z" itemprop="datePublished">2020-02-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/10/联盟链-Fabric比较其他联盟链的优势/">
        (转)联盟链，Fabric比较其他联盟链的优势
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>联盟链是目前区块链落地实践的热点，也是大家对“杀手级应用”期望最大的区块链部署形态。联盟链的诞生源于对区块链技术的“反思”，是对比特币、以太坊所体现的技术特点与企业客户实际需要的融合与折衷，蕴含了大量区块链工作者的智慧与辛劳。</p>
<p>由于对未来价值的“共识”，很多厂商推出了自己的联盟链框架或平台，本文选择了 Hyperledger Fabric、FISCO BCOS、微软的 Coco、企业以太坊联盟（EEA）及 R3 的 Corda 这五个具有一定影响力的联盟链，拟从设计理念、生态、效率、扩展性、节点管理与权限管理、智能合约、部署与运维友好性、隐私保护、公链结合或演化能力九个方面进行比对，以供各位开发者、爱好者参考。</p>
<p>其中，EEA 由于只出具规范而不涉及代码，所以比对中采用了其官方承认的技术基础——摩根大通的 Quorum 平台；Corda 并不是区块链，严格说与其他四者的比较属于分布式账本技术这个层级的比较，但是由于其承认设计上是受到区块链技术启发，且对其他联盟链也产生了一定的影响，因此，也列入了比较范围。本文的信息主要来源于公开的技术白皮书、Github 中的开源信息，就不在文中一一注明了。</p>
<p>#一、设计理念</p>
<p>设计理念其实决定了一个框架或者系统的最佳应用方式，是其设计的出发点，因此，研究每种区块链时，都应当认真关注其如何“看待自己”，以免在应用上出现“硬套”的问题。设计理念上本文分成核心思路与市场定位两部分进行比较。</p>
<p>##（一）核心思路</p>
<p>核心思路体现的是其设计初衷，这个“初心”对其后续技术走向有一定的影响。</p>
<p>Hyperledger Fabric 是希望改变公链的单一通用网络模式，通过建立多个可以互联的区块链网络覆盖各类不同的业务场景，实现设计的灵活性，满足多样化的要求，并实现网络间的交互，这种思路体现在了其独特的通道机制设计上。</p>
<p>FISCO BCOS 初衷是设计一个国内企业主导研发、自主可控、对外开源的满足金融行业需求企业级区块链底层平台，并逐渐扩展至其他领域、适用于广泛的分布式商业场景，所以进行了自底向上的完整设计，并考虑了较多国内的特殊需求。</p>
<p>Coco 基于保密联盟环境的假定，重新评估了公链的设计，通过将其他区块链协议集成为底层，快速高效地构建区块链应用。在这种思路下 Coco 大胆放松了一些关键的设计限制，并且最终实现了一个对现有区块链协议的加速机制，可集成的协议已经包括 Hyperledger Fabric、以太坊、Corda、Quorum 等。</p>
<p>EEA 是力求引导一种基于以太坊的标准区块链设计，可根据成员需要定制，但不提供代码（Quorum 提供部分开源代码）。官方承认其技术基础是摩根大通开发的 Quorum 平台，该平台的目标则是提供高速、高吞吐量交易的能力，以解决区块链技术在金融等领域遭遇的挑战。</p>
<p>Corda 希望提供一个具有唯一性、权威性、可以记录企业间所有协议的全局逻辑账本，核心是实现具有节点间最小信任机制的无中心数据库，因此，Corda 主张充分考虑与现有业务系统的结合，而非将现有业务系统拆掉重来。Corda 的设计思路对 Hyperledger Fabric 有一定影响，也参与了对后者的建设。</p>
<p>##（二）市场定位</p>
<p>市场定位反映了对自身应用方向的价值主张。五个联盟链都是面向企业级应用的，但是具体的定位略有差异：</p>
<p>Hyperledger Fabric 旨在打造不分行业的通用区块链开源框架；</p>
<p>FISCO BCOS 源自企业级区块链平台 BCOS，做为一个金融版本分支，保留通用性的同时，更关注于金融行业，并且较多考虑了监管机构的特殊性；</p>
<p>Coco 希望提供更高效易用的区块链技术，没有特殊的行业定位；</p>
<p>EEA 比较有趣，它以将所有企业导向一个统一的路线图（该路线图以以太坊技术发展为基础）为目标，但是由于目前的技术代表是摩根大通的 Quorum，所以，应用实例上对金融行业更有指导性；</p>
<p>Corda 则是针对金融行业的，并且明确提出至少一定时间内不会考虑其他行业。</p>
<p>从设计理念的角度来讲，选用 Hyperledger Fabric 时，应当善用其通道机制，通过通道机制降低业务或者环境的复杂度，但是要注意其跨通道能力的一些技术限制；FISCO BCOS 则应关注其对国内市场特殊需求的适应性设计，这些设计会带来很多部署上的优势；Coco 和 EEA（Quorum）设计理念上都属于基于现有协议的优化加速机制，只是前者“博爱”，兼容的协议更多，后者“专一”，只针对以太坊；选用 Corda 则要先明确，它不是区块链，不要带着区块链的价值假定去应用。</p>
<p>#二、生态</p>
<p>大家常说建联盟链就是建生态，所以本文就比较下要帮着别人建生态的联盟链，其自身的生态建的如何。生态考察主要包括管理方、社区和商业应用这三个方面。</p>
<p>##（一）管理方</p>
<p>从管理方看，各家都是“实力派”。</p>
<p>Hyperledger Fabric 的管理方是 Linux 基金会，基金会管理下的 Hyperledger 其实是一个项目系列，包括 Cello、Swatooth、Burrow、Iroha 等；</p>
<p>FISCO BCOS 管理方是金链盟，金链盟是由深圳市金融科技协会、深圳前海微众银行、深证通、腾讯、华为、中科院等金融机构、科技企业、学术机构等组成的非营利性组织；（参考 <a href="https://www.fisco.com.cn/views/member.html）" target="_blank" rel="noopener">https://www.fisco.com.cn/views/member.html）</a></p>
<p>Coco 的管理方是微软；</p>
<p>EEA 是由芝加哥交易所、因特尔、ING、摩根大通和微软等三十几家创始成员组成的；</p>
<p>Corda 的管理方 R3 是以银行为主的组织，至少已经吸收了 42 家金融巨头，包括富国银行、美国银行、花旗银行、德意志银行、加拿大皇家银行等，我国的平安、招行等也是其成员，不过 R3 麻烦不断，也有些重量级成员已经退出。</p>
<p>##（二）社区</p>
<p>现今科技发展比较流行开源，五大联盟链也都是开源的，开源意味着要搞好社区建设，通过社区推广和改进设计，凝聚更多智慧。</p>
<p>Hyperledger Fabric 已经打造了国际化的社区，除了在 GitHub 上比较活跃外，大量的线下 Meetup、技术推广活动也比较多，加上 IBM 的有力推动，使其有了大量的活跃用户；</p>
<p>FISCO BCOS 社区建设初现规模，已有了千级成员、百级机构参与，除了 GitHub 外，还有官方微信群。FISCO BCOS 在不断迭代源码和文档的基础上，陆续推出了线上线下多种形式的系列运营活动，包括技术培训、高校开课、线上线下讲座沙龙、包括近期举办的金链盟中国区块链大赛，影响力逐渐扩散。作为国内开源项目，相信未来发展上会有一定的“天时地利人和”；</p>
<p>Coco 社区不是很活跃；</p>
<p>Quorum 在 GitHub 上已经有了 551 个话题，有一定活跃度；</p>
<p>Corda 也不是很活跃。</p>
<p>##（三）商业应用</p>
<p>商业应用是大家打造区块链平台的目的，也是一个联盟链最重要的人气所在。</p>
<p>Hyperledger Fabric 得益于 IBM 的大力推广，加上技术框架比较成熟、推出较早，目前已有较多商业应用，据 IBM 披露有 400 多个落地项目，其中不乏马士基、沃尔玛、联想、邮储银行这类大型客户，也有统计称，所有联盟链项目中 Hyperledger Fabric 已占据半壁江山；</p>
<p>FISCO BCOS 从金融出发，携本土优势，落地项目也有数十个，包括微众银行的机构间对账平台、网易的竞猜游戏，四方精创的供应链金融、城商行旅游金融联盟的旅游金融、仲裁链、安妮股份的版权存证平台、乐寻坊的人才活动平台、链动时代的不动产登记系统等；</p>
<p>Coco 目前在项目方面乏善可陈，除了其白皮书中提到的 Mojix 将其供应链 Dapp 转移到 Coco 平台上之外，没有更多公开的项目信息；</p>
<p>Quorum 上，比较有影响的应该算是 2017 年 10 月摩根大通开发的 IIN（Interbank Information Network）平台，实现跨行信息交互，摩根大通、加拿大皇家银行、澳大利亚 ANZ 银行、新西兰银行等相继加入该平台；</p>
<p>Corda 也是同样的境地，雷大雨小，耗费巨资，但是测试的多，落地的少。</p>
<p>从生态角度看，Hyperledger Fabric启动的比较早，目前领先一步，但是 FISCO BCOS 奋起直追，已经初见规模，Coco、Quorum、Corda 还需要做很大努力。</p>
<p>#三、效率</p>
<p>区块链目前最差强人意的指标莫过于效率，虽然现在也有些人开始反思也许不应当苛求区块链的效率，但是商业应用总是回避不了这个问题。效率方面，本文从共识协议、出块速度、TPS 和存储消耗这四点加以比对。</p>
<p>##（一）共识协议</p>
<p>联盟链为了提升交易速度，往往是先从共识协议“下手”。POW 和 POS 都无法满足商业应用的需要，“挖矿”对联盟链来讲也是没必要的，因此，各家都采用了替代的共识方案。</p>
<p>Hyperledger Fabric 在 0.6 版中应用了 PBFT，而在 1.0 版中放弃了 PBFT，转而采用效率更高的 Kafka，支持单点和集群两种方式，由 Kafka 直接给交易排序和出块。</p>
<p>FISCO BCOS 支持并行计算的 PBFT 和标准 RAFT 两种方式，前者是将通常的 PBFT 中议长节点和投票节点分步验证的方式优化为并发验证，从而进一步提高共识效率；</p>
<p>Coco 支持 Paxos 和 Caesar 两种协议。由于 Coco 节点是建立在基于硬件的 TEEs（可信执行环境）上，因此就假定了节点充分可信，所以在 Paxos 中，leader 节点处理过的事务，follwer 节点简单跟随即可，这体现了其对公链假定的改变；Caesar 支持灵活的容错模型，可以与 Paxos 共同使用以防范 leader 节点由于 TEEs 遭到破坏产生的安全威胁，该协议支持在 follwer 节点发现 leader 节点不可靠时将其驱逐，从而保证全网的安全；</p>
<p>Quorum 支持 Raft 和 Istanbul BFT 两种协议。后者是由来自台湾的 AMIS 帐联网公司在 2017 年研发的，可以大幅提升现有的以太坊架构的讯息交换效率；</p>
<p>Corda 比较特殊，它借鉴“矿工”角色设计了公证人模块来提供交易公证（也即签名）服务，整个网络不依赖于任何特定的共识算法。但公证人是一个集群概念，一般使用 BFT 或 Raft 在公证人间达成一致，因此，公证人是存在效率问题，可能成为效率瓶颈；</p>
<p>与传统分布式系统的共识设计相比，Hyperledger Fabric 并没有什么改进，其共识方式与中心化共识的分布式数据库一致；FISCO BCOS 支持 PBFT 共识算法，具备拜占庭容错功能，也提供 RAFT 共识算法，适用于在节点可信度比较乐观的场景；Coco 是通过 TEEs 提高节点可信性，以降低共识协议的复杂度；Quorum 也没做多少调整，尤其是在引入 Istanbul BFT 之前；Corda 应该说是在传统设计中引入了“矿工”理念。</p>
<p>##（二）出块速度</p>
<p>由于替换了共识机制，因此相比使用 POW 的比特币、以太坊，联盟链出块速度要提高很多。Hyperledger Fabric、FISCO BCOS、Coco 都是秒级出块；Quorum 则称是毫秒级，默认设定是 50 毫秒，可以调整；Corda 没有块，所以也没有出块速度可以考量。</p>
<p>##（三）TPS</p>
<p>TPS 相当于区块链世界中的“网红”，很多新出现的链都把 TPS 贴在“脑门”上。这五大联盟链虽然 TPS 远高于比特币、以太坊，但还是比现有的分布式系统逊色：</p>
<p>Hyperledger Fabric 通常实测的 TPS 在 300-500 之间；</p>
<p>FISCO BCOS 实测单链可以达到 1000 以上。并且支持多链架构下的并行计算，可灵活扩展，理论上无上限。</p>
<p>Coco 官方数据是 1600；</p>
<p>Quorum 在 Istanbul BFT 协议下可以达到 400-800，Raft 下缺少数据；</p>
<p>Corda 由于其网络结构的原因，没有全局吞吐量可以衡量。</p>
<p>其实 TPS 方面如果没有达到一个数量级以上的差异，是不用特殊关注的，因为在实际应用中，节点数量、网络环境、硬件配置、软件设计等都会对 TPS 产生影响，而现有的联盟链在吞吐量上已经可以满足相当一部分商业场景的要求，毕竟 Visa 在 2016 年每秒实际处理的交易也只有 1，667 笔，尽管 Visanet 据称有每秒处理 56，000 笔交易的能力。</p>
<p>##（四）存储消耗</p>
<p>区块链可以说是以“浪费”存储来换取信任的技术。虽然存储设备的价格越来越低廉，但这不代表“浪费”就没毛病，存储的快速膨胀一定会带来效率、成本、可用性等诸多问题，甚至会要求改变设计架构，尤其是在大家都想追求“杀手级应用”的时候。</p>
<p>Hyperledger Fabric 方面，蚂蚁金服倒是给出了一个详细的计算公式，Fabric 数据容量估算（GB） = 每种业务每天平均交易笔数 x （Fabric 每笔交易基本开销 + 每笔交易平均业务数据大小 KB x 2 ） x 业务 Channel 数量 x（365 x 年数 x（Peer 节点数量 x 2~1 之间 + Orderer 节点数量）+ Kafka RetenTIon 天数 x Kafka Replica 数量） / （1024 x 1024），其计算示例中，在业务笔数每天 10 万、4 节点、2 通道、单笔交易容量 1K 的情况（其他因素不详细列出了）下，年存储消耗 4619G；</p>
<p>FISCO BCOS 支持历史数据快速追踪，对接数据库，实现分布式存储，能够支持海量服务的存储需求，提高存储访问速率，节省存储消耗。</p>
<p>Coco 由于设计上需要集成区块链协议做底层，因此其消耗就取决于集成的区块链协议，比如集成了 Hyperledger Fabric，那加上 Coco 自身的消耗，其存储消耗量至少应该是比肩 Fabric 的；</p>
<p>Quorum 也没有针对存储的特殊优化，至少应当按照大于以太坊消耗来估算；</p>
<p>Corda 倒是不同于其他联盟链，因为它基本上就是传统的分布式数据库，而且没有任何节点保存全局数据，每个节点都只保存跟自己有关的数据，所以，其存储消耗应该与传统分布式系统设计类似，没有过多的冗余消耗。</p>
<p>综上，从效率方面看，在 Hyperledger Fabric 之后推出或开源的其他联盟链，效率高于它也属正常。FISCO BCOS、Quorum 本就是面向金融的设计，所以效率要求自然要高于一开始就希望做通用框架 Hyperledger Fabric；Coco 设计理念上就是希望做成“加速器”的，它的效率理应高于任何它可以集成的区块链；而 Corda 的设计模式决定了很难全面评价其效率，只能去单独观察每个实例。</p>
<p>#四、扩展性</p>
<p>联盟链的用户都希望自己能发展成生态圈，比如海尔的供应链、中化的原油进出口贸易平台、马士基的全球交易平台等，因此，扩展性是联盟链设计必须要考虑的问题。这方面本文关注了节点数量扩展、共识扩展、单多链模式、加密算法扩展、第三方认证证书支持这五点。</p>
<p>##（一）节点数量扩展</p>
<p>Hyperledger Fabric 在节点数量扩展方面是弱项，已落地项目多是个位数节点，但是可以支持较多的客户端，算是一种弥补，不过节点数少其实意味着参与方的独立性是会有所下降的；</p>
<p>FISCO BCOS 的分组模式支持根据节点数量进行水平扩容，因此理论上节点数量是不受限制的；</p>
<p>Coco 在这方面有些“投机取巧”，可支持的节点数量取决于其集成的区块链协议，如果集成的是公链协议，在理论上也不受限制；</p>
<p>Quorum 是基于以太坊的，因此理论上也没有限制；</p>
<p>Corda 同样也没有节点数限制。</p>
<p>虽然除了 Hyperledger Fabric，其他联盟链似乎都没有节点数量问题，但是节点数量其实还受共识协议的影响，BFT 类共识协议在节点数量超过一定水平时会出现吞吐量下降，设计时应当考虑这点。</p>
<p>##（二）共识协议扩展</p>
<p>共识协议的扩展能力对联盟链的稳定性有很大影响，能否根据节点数量、网络平衡情况、吞吐量进行调整决定了其网络的扩展能力。</p>
<p>Hyperledger Fabric 虽然很早在设计上就称其共识模块可插拔，但是目前实际应用上看是不具备插拔能力的，每个版本仅支持一种共识模式；</p>
<p>FISCO BCOS 支持共识协议的插件式实现，允许切换共识机制；</p>
<p>Coco、Quorum 目前也具备了这种能力；</p>
<p>Corda 实现的应该说不是共识协议的直接插拔，而是公证人模块的可插拔，可以通过切换公证人模块来选择公证人的共识模式。</p>
<p>##（三）单多链模式</p>
<p>多链模式目前被很多新出现的链用于性能扩展，不过多链模式有利有弊，提升性能的同时也增加了设计复杂度。</p>
<p>Hyperledger Fabric 的通道机制其实可以算是早期的多链设计，但是通道在 Hyperledger Fabric 中并不是出于提升效率的目的设计的，而是为了满足业务多样性要求，以降低业务复杂度，因此，通道机制目前在性能扩展方面没有显著贡献；</p>
<p>FISCO BCOS 是明确的并行计算多链设计，设计上要求开发者尽可能保持多链的同构特征以减少冲突，多链设计被直接应用在系统扩展方面；</p>
<p>Coco 的模式仍然取决于其集成的区块链协议；</p>
<p>Quorum 是单链模式的，底层的性能扩展要跟随以太坊的技术路线，可能要依赖以太坊的分片等技术进行扩展；</p>
<p>Corda 设计上是多网络模式，没有单多链的概念，但是可以建立两个网络节点的双向连接，配置双方信任的公正和认证机构进行网络融合，融合算是其扩展的一种方式。</p>
<p>##（四）加密算法扩展</p>
<p>对于国内的应用，加密算法的扩展也即国密替换是一个强烈需求，尤其是在金融领域。</p>
<p>Hyperledger Fabric 不支持国密替换，目前已有的应用凡实现国密的基本上是自行替换或者依赖第三方服务；</p>
<p>FISCO BCOS 是支持国密的；</p>
<p>Coco 未对加密算法的选择有明确说明，因为这对 Coco 而言属于底层，取决于其集成区块链协议，但目前它所集成的协议中还没有支持国密的；</p>
<p>Quorum、Corda 都没有对国密的支持方案。</p>
<p>##（五）第三方认证证书支持</p>
<p>这一点对国内的应用也很重要。</p>
<p>Hyperledger Fabric 目前不支持第三方 CA；</p>
<p>FISCO BCOS 支持第三方证书，支持证书的撤销，支持多CA；</p>
<p>Coco 由于私钥都保管在本地业务系统且允许自己生成，网络上只存公钥集，因此技术上看应该可以支持第三方 CA；</p>
<p>Quorum、Corda 都未见有此类支持。</p>
<p>综上，Hyperledger Fabric 在扩展性上有一定的限制； FISCO BCOS 的可扩展性是很有优势的，尤其是面向国内应用时；Coco 扩展性取决于其集成的协议；Quorum 的扩展性与以太坊关系密切；Corda 除了在加密算法和第三方认证证书方面外，扩展的自由度有可能是最高的。</p>
<p>#五、节点管理与权限管理</p>
<p>除了共识之外，联盟链与公链的显著区别当属在节点和权限上的设计了。本文从节点类型、作用、成员准入控制、角色和权限管理这几个方面比较下各联盟链之间的差异。</p>
<p>##（一）节点类型</p>
<p>Hyperledger Fabric 网络中的节点主要分为排序节点、背书节点和记账节点三类，实际应用中还可以加入只有同步账本能力的二级节点；</p>
<p>FISCO BCOS 中包含核心节点、全节点、轻节点；</p>
<p>Coco 是一个可信验证节点（VN）分布式网络，也即，它只有一类节点就是 VN；</p>
<p>Quorum 中的节点是基于的以太坊 Golang 版本实现的，因此节点之间是对等的，没有节点类型的区分，节点之间可以有白名单管理；</p>
<p>Corda 也不区分节点类型。</p>
<p>##（二）节点作用</p>
<p>Hyperledger Fabric 网络中背书节点负责提供签名服务，经背书节点签名且满足签名策略的交易提案会提交给排序节点进行交易排序和出块，再由记账节点完成账本更新；</p>
<p>FISCO BCOS 中核心节点负责共识和记账，共识节点参与记账共识， 观察节点同步账本；</p>
<p>Coco、Quorum、Corda 中节点都是对等的。</p>
<p>##（三）准入控制</p>
<p>Hyperledger Fabric 中有专门的 CA 模块提供用户信息注册、数字证书发行、延期和吊销等服务，成员管理采用 MSP 方式，同一个组织内的成员通过共用同一个 MSP 标识进行识别；</p>
<p>FISCO BCOS 中，成员加入网络采用管理员认证的方式，提供合法有效的成员信息与CA证书，由管理员审核通过后，加入网络；</p>
<p>Coco 网络中的角色分为成员和参与者两种，成员是网络的集体管理者，拥有投票权，投票决定其他机构的加入或删除；</p>
<p>Quorum 网络中节点通过授权才能加入网络，授权是集中式的，通过 Java 控制台操作；</p>
<p>Corda 中节点也是需要授权加入的，节点选择加入一个或多个网络地图，网络地图相当于网络成员及其地址列表，节点只能与所在地图中的成员进行交易。</p>
<p>##（四）角色</p>
<p>Hyperledger Fabric 中虽然成员没有明确的角色划分，但是基于其运维或对应的节点的差异会自然形成不同的角色；</p>
<p>FISCO BCOS 网络中的角色包含超级管理员、链或权限管理员、运维、交易、监管等；</p>
<p>Coco 网络中的角色分为成员和参与者两种，但不是必须同时具有两类参加者，也可以只有成员类型；</p>
<p>Quorum 网络中没有角色的区分；</p>
<p>Corda 网络中的角色分为公证人和参与者两种，公证人提供公证服务，参与者进行交易。</p>
<p>##（五）权限管理</p>
<p>Hyperledger Fabric 中权限主要通过策略进行管理，策略实际上是成员通过节点进行某种操作，比如提交交易提案等，所需要满足的签名数量要求。</p>
<p>FISCO BCOS 权限管理采用系统合约的方式，并可以通过自定义合约的方式进行权限管理功能的扩展，权限管理模型为 ARPI（账户——角色——权限——接口）模式，多个账户可以对应同一个角色，角色有明确的权限列表，每个权限对应一个接口，接口指向智能合约，权限列表按照系统合约方式维护。业务中的权限管理则采用交易权限链的方式，一个交易相当于一组权限链，包含多个 Filter，交易处理是逐个 Filter 进行权限判断，一个交易完成相当于一组 Filter 审核都通过。</p>
<p>Coco 网络有成员负责治理，参与者是没有投票权的，不能参加网络管理。成员和参与者都可以拥有 VN。成员对网络的管理通过共同维护一个可编程的网络章程来进行，章程内容至少包括成员列表、VN 列表、代码清单、TEE 清单和投票策略。</p>
<p>Quorum、Corda 没有明显的权限管理内容。</p>
<p>综合比较，FISCO BCOS 的设计比较周全，也有一定的复杂性，但这也意味着它能够支持更复杂的场景； Hyperledger Fabric 、Coco 带有一定中心化因素；相较之下，Quorum、Corda 更接近公链思路。带有中心化因素本就是联盟链对其应用的商业环境的体现，这也无可厚非。</p>
<p>#六、智能合约</p>
<p>为了提升效率，支持更加友好的设计，各联盟链在智能合约上也出现了不同的发展思路。</p>
<p>Hyperledger Fabric 中的智能合约称为“链码”。链码分为系统链码和普通链码，前者包括生命周期管理、配置管理等，属于系统控制层面的链码；普通链码则是用于实现业务逻辑的链码，智能合约开发通常指的就是这部分链码。链码的业务模型为“MCV-B”，即，在传统的 MVC（模型、控制器、视图）模式中嵌入 B（区块链），强调链码是业务逻辑的加强。链码的生命周期包括打包、安装、实例化、升级、停止和启动，运行在 Docker 中，由背书节点进行调用，目前主要支持的是 Go 语言。Hyperledger Fabric 虽然提供了跨通道机制，允许跨通道调用链码，但是跨通道调用只支持读而不支持写。</p>
<p>FISCO BCOS 中除了通常用于业务逻辑的智能合约外，将系统管理也智能合约化了，统称为系统合约，包含系统代理、节点管理、机构证书、权限管理、全网配置五类。上述合约原则上由区块链管理员在网络启动时部署，网络运行期间的变更则需要在去全网所有节点许可的情况下由管理员操作。FISCO BCOS 主要支持 EVM 引擎的智能合约。</p>
<p>Coco 由于其节点运行在可信执行环境中，因此，与其他联盟链不同的是智能合约只需单个节点运行，不必多次验证。更与众不同的是，因为可以单点只运行一次，所以 Coco 的智能合约支持不确定交易。此外，允许智能合约直接连接外部可信数据源。</p>
<p>Quorum 是基于以太坊智能合约的，智能合约本身没有特别之处，合约运行结果方面，节点只对公开交易和节点涉及的私有交易进行验证，而不必验证所有交易。</p>
<p>Corda 的智能合约设计思路也比较独特，首先，它主张智能合约的业务数据和业务逻辑要能关联到明确的法律依据上，这相当于要智能合约跟业务凭证之间具有强联系；其次，Corda 主张纯函数式设计，力推金融合约的标准化，提供小型类库，以减少对低层次逻辑的重新开发；再次，单纯看智能合约的话，Corda 的智能合约是“碎片化”的小段程序，而且只能做为起流转控制作用的“验证程序”，做不到一般智能合约那种价值转移功能，在 Corda 中，“交易”、“智能合约”和“流式架构”加起来才能与其他平台的智能合约相当。</p>
<p>总结一下，Hyperledger Fabric 的链码设计给了智能合约一个新的设计框架，这方面它是开创性的；FISCO BCOS 则将智能合约应用扩展到了系统管理方面；Coco 采取了改变公链设计假定的思路，不仅不对智能合约进行重复验证，还支持不确定交易；Quorum 的智能合约基本沿袭公链思路；Corda 的思路也比较另类，但是智能合约本身却更弱化了。</p>
<p>智能合约是随着以太坊火起来的，成了区块链的标志性技术，但其实目前的智能合约还远不够“智能”，这个名字容易引起误解。以太坊创始人 Vitalik 最近在推特上发文称对使用智能合约这个术语表示“十分遗憾”，应该使用更专业或更无聊的名字，比如，“持续的脚本”之类的东西，想来也有此意。</p>
<p>#七、部署与运维友好性</p>
<p>联盟链常被称为是个“坑”，这个“坑”主要是在部署和运维方面。</p>
<p>##（一）部署</p>
<p>Hyperledger Fabric 虽然已经是个成熟框架了，有良好的社区环境，市面上还有若干不错的教材，但是部署方面依然让很多新人不知就里，笔者所在的微信群里大部分时间都在交流部署问题而非设计问题；</p>
<p>FISCO BCOS提供一键安装/step-by-step/docker等搭链方式，同时还未企业生产部署提供物料包的打包工具，简化部署复杂度；</p>
<p>Coco 的部署特点是增加了一次对其他区块链协议的集成，要先有底层区块链协议，才能部署 Coco，这其实要设计人员对 Coco 和其集成的区块链协议都有一定了解才好，学习成本较大，此外，Coco 需要部署 TEE 硬件设备来支持可信执行环境构建，这是其他联盟链通常不需要的，TEE 因此也成为一个安全隐患；</p>
<p>Quorum 需要在以太坊之上部署，依赖以太坊，与 Coco 相同，设计人员最好也要了解以太坊；</p>
<p>Corda 的部署目前缺乏实例来做比较。</p>
<p>##（二）运维</p>
<p>Fabric 目前没有提供多少支持工具，多数需要设计者自己开发；</p>
<p>FISCO BCOS 提供了方便运维的合约命名服务，提供区块链浏览器和监控，并且有上帝模式用于处理节点崩溃问题，运维友好度有一定改善；</p>
<p>Coco 目前未见提供多少运维工具；</p>
<p>Quorum 有一些第三方支持工具；</p>
<p>Corda 与其他联盟链相比，运维方面最大的特色莫过于支持受限形式的数据库回滚。</p>
<p>联盟链的部署和运维都有一定的学习曲线，其复杂度远高于公链，一个新手部署一条以太坊要不了多少时间，但是运转起一个联盟链，还是需要打听不少“小伙伴”的。</p>
<p>#八、隐私保护</p>
<p>联盟链有一个让大家纠结的问题是，明明要上链一起共建生态、共享信息，却纷纷要求隐私保护，要上链又不能随意公开，不仅希望身份保密，还希望交易信息保密，这与公链信息公开、身份保密的设计理念有很大不同，但这是合理要求，尤其是在金融领域。本文从可见范围、加密措施两方面对各链加以比较。</p>
<p>##（一）可见范围</p>
<p>Hyperledger Fabric 的通道可以用来隔离数据，只有在同一通道内的节点才可以共享同一套账本信息，而通过组织设计，基于 MSP 标识可以在同一通道内进一步控制数据可见范围，1.2 版中加入了私有数据模式，允许指定的节点间共享信息，这比组织更加灵活；</p>
<p>FISCO BCOS 设计了 AMOP 协议，以提供机构间的点对点通信，通信信息属于链下信息，不在全网共享，链上部分在引入中央对手方提供信用背书的情况下，数据也仅在交易方和中央对手方之间共享，多链方式也可用于数据隔离，必要时通过跨连互通；</p>
<p>Coco 支持两个或多个交易者的机密交易，通过 TEE 控制可见性，但要求集成的区块链协议最好也提供一定支持；</p>
<p>Quorum 区分公开数据和私有数据，私有数据只允许限定的交易方可见；</p>
<p>Corda 数据仅在交易方之间可见，节点之间提供一个交易依赖关系图，数据根据需要发送，而不在全局广播，任何参与方都无法见到包含全部数据的全局账本。</p>
<p>##（二）加密措施</p>
<p>Hyperledger Fabric 1.1 开始支持账本数据加密，1.2 版引入私有数据后，设计上允许只给 Kafka 提供交易 Hash 用于排序而不向 Kafka 提供交易信息，以防排序节点泄露数据；</p>
<p>FISCO BCOS 允许采用高强度的加密数据信封进行保护，未参与交易的机构只能接收到密文，此外，建议对敏感数据采用脱敏上链、Hash 上链等方式进行保密处理；支持零知识证明，环签名，群签名，同态加密等隐私保护方法。</p>
<p>Coco 允许应用程序先进行数据加密再提交事务，公网数据采用加密传播的方式，以对不受信任的 host 保密；</p>
<p>Quorum 有独立的 ConstellaTIon 模块，对私有事务的交易数据进行加密保护，还提供了独立的零知识证明（ZSL）模块以防止验证用户身份时发生信息泄露；</p>
<p>Corda 也使用 enclave 进行数据保护，并考虑使用安全硬件。</p>
<p>在隐私保护上，各链都下了很大力气，这方面与其一较短长，不如考虑互相借鉴。</p>
<p>#九、选型建议</p>
<p>通过以上八个方面，本文粗略比较了五大联盟链的设计与差异，如果非要从技术角度给各家打个分、排个名，实在有些“霸王硬上弓”之嫌，各家原本思路和焦点就不同，都有自己的“小目标”，非要不管人家自己的想法去论个短长，有些不太“科学”，也不是应用的合理“姿势”。各联盟链毕竟都是为了解决实际问题、为了落地区块链项目而设计的，所以，本文最后从大家都会关心的技术选型角度做个总结。</p>
<p>整体而言，Hyperledger Fabric 的综合实力依然最强，推出时间早、框架完整且比较成熟，有国际化应用和国际化社区加持，案例和技术支持对于仍属早期发展阶段的区块链而言非常重要，Hyperledger Fabric 在这方面可以说优势极大。但是，它也有些不能回避的问题，比如基础研发进展缓慢，研发主体不明确，一些应用者关心的关键问题迟迟不见解决。随着百度、阿里、腾讯、京东等一众国内大厂的强势加入，Hyperledger Fabric 的优势地位也会受到越来越多的挑战，对此，它急需合适的应对措施。</p>
<p>FISCO BCOS 应该说是本土化设计的代表，其在底层研究上的投入、关键技术上的改进、对国内需要的适应性调整、对社区建设和运维的重视，都有可圈点之处，平台在各行业的通用性也在加强，随着开源工作的推进和案例的不断增加，其本土化优势会逐步显现。在国家政策的鼓励下，国内大厂如今纷纷高调杀入联盟链市场，如果这些大厂真的“倾情”加入，那与 Hyperledger Fabric 相较，其开发主体、资金投入的稳定性要更有优势，而且，大厂们基本自带生态和流量，案例的增长、生态的发展也是可以预期的，是很多项目可以借力之处。</p>
<p>Coco、Quorum、Corda 都存在支持能力不足、缺乏有效案例的问题，虽然微软目前在 Coco 以及其他基于 Azure 的区块链平台和应用上投入了一定力量，但是对国内应用者而言，仍显不足。</p>
<p>因此，从技术选型角度来讲，应用者，尤其是新入局的应用者，最好还是在 Hyperledger Fabric 这种影响广泛的成熟框架或者 FISCO BCOS 这种有实力且能提供较强本土支持的平台上做选择，而在开发过程中借鉴下 Coco、Quorum、Corda 中的优秀设计理念。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-红黑树" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/10/红黑树/" class="article-date">
  	<time datetime="2020-02-10T02:40:34.937Z" itemprop="datePublished">2020-02-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://zhuanlan.zhihu.com/p/97523789" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/97523789</a></p>
<p><a href="https://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2020 zhangyong
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>